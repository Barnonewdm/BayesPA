!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ABLAS	utils/ap.cpp	/^HINSTANCE ABLAS = LoadLibrary("ablas.dll");$/;"	v
APVT_H	utils/apvt.h	/^#define APVT_H$/;"	d
AP_ASSERT	utils/ap.h	/^#define AP_ASSERT$/;"	d
AP_H	utils/ap.h	/^#define AP_H$/;"	d
AP_UNKNOWN	utils/ap.h	/^#define AP_UNKNOWN$/;"	d
Array	paMedLDA-ave.cpp	/^Array<T>::Array() {$/;"	f	class:Array
Array	paMedLDA-ave.h	/^	class Array {$/;"	c	namespace:paMedLDA_averaging
Array	utils/Array.h	/^class Array {$/;"	c
COST_PARAMETER	utils/defs.h	/^#define COST_PARAMETER /;"	d
Cdk	paMedLDA-ave.h	/^		double **Cdk, **Ckt;$/;"	m	class:paMedLDA_averaging::LocalSample
Ckt	paMedLDA-ave.h	/^		double **Cdk, **Ckt;$/;"	m	class:paMedLDA_averaging::LocalSample
Ckt_sum	paMedLDA-ave.h	/^		double *Ckt_sum;$/;"	m	class:paMedLDA_averaging::LocalSample
Commit	paMedLDA-ave.h	/^	}Commit;$/;"	t	namespace:paMedLDA_averaging	typeref:struct:paMedLDA_averaging::__anon3
Corpus	Corpus.cpp	/^Corpus::Corpus() {$/;"	f	class:Corpus
Corpus	Corpus.h	/^class Corpus {$/;"	c
CorpusData	Corpus.h	/^}CorpusData;$/;"	t	typeref:struct:__anon2
D	Corpus.h	/^	int D;					\/\/ total number of documents.$/;"	m	struct:__anon2
DEBUG_PRINT	utils/debug.h	/^#define DEBUG_PRINT /;"	d
Document	Corpus.h	/^}Document;$/;"	t	typeref:struct:__anon1
GetData	utils/apvt.h	/^    T* GetData()$/;"	f	class:raw_vector
GetData	utils/apvt.h	/^    const T* GetData() const$/;"	f	class:const_raw_vector
GetLength	utils/apvt.h	/^    int GetLength() const$/;"	f	class:const_raw_vector
GetStep	utils/apvt.h	/^    int GetStep() const$/;"	f	class:const_raw_vector
GlobalSample	paMedLDA-ave.cpp	/^GlobalSample::GlobalSample(paMedLDAave* medlda){$/;"	f	class:GlobalSample
GlobalSample	paMedLDA-ave.h	/^	class GlobalSample {$/;"	c	namespace:paMedLDA_averaging
INVMVGAUSSIAN_H	utils/InverseGaussian.h	/^#define INVMVGAUSSIAN_H$/;"	d
InverseGaussian	utils/InverseGaussian.cpp	/^InverseGaussian::InverseGaussian(void)$/;"	f	class:InverseGaussian
InverseGaussian	utils/InverseGaussian.h	/^	InverseGaussian(double dMu, double dScale) {$/;"	f	class:InverseGaussian
InverseGaussian	utils/InverseGaussian.h	/^class InverseGaussian$/;"	c
LocalSample	paMedLDA-ave.cpp	/^LocalSample::LocalSample(paMedLDAave* medlda, CorpusData* data) {$/;"	f	class:LocalSample
LocalSample	paMedLDA-ave.h	/^	class LocalSample {$/;"	c	namespace:paMedLDA_averaging
MIN_GIBBS_ITERATION	utils/defs.h	/^#define MIN_GIBBS_ITERATION /;"	d
MT_K	utils/objcokus.h	/^#define MT_K /;"	d
MT_M	utils/objcokus.h	/^#define MT_M /;"	d
MT_NT	utils/objcokus.h	/^#define MT_NT /;"	d
MVGaussian	utils/MVGaussian.cpp	/^MVGaussian::MVGaussian(void)$/;"	f	class:MVGaussian
MVGaussian	utils/MVGaussian.h	/^class MVGaussian$/;"	c
NO_AP_ASSERT	utils/ap.h	/^#define NO_AP_ASSERT /;"	d
NO_AP_ASSERT	utils/ap.h	/^#undef NO_AP_ASSERT /;"	d
NUMERICAL_ZERO	utils/defs.h	/^#define NUMERICAL_ZERO /;"	d
OVERFLOW_THREHOLD	utils/defs.h	/^#define OVERFLOW_THREHOLD /;"	d
OnlineTopic_apaux_h	utils/apaux.h	/^#define OnlineTopic_apaux_h$/;"	d
OnlineTopic_debug_h	utils/debug.h	/^#define OnlineTopic_debug_h$/;"	d
UINT32_MAX	utils/utils.h	/^#define UINT32_MAX /;"	d
Z	paMedLDA-ave.h	/^		int **Z; $/;"	m	class:paMedLDA_averaging::LocalSample
Zbar	paMedLDA-ave.h	/^		double **Zbar;$/;"	m	class:paMedLDA_averaging::LocalSample
_DEFS_H	utils/defs.h	/^#define _DEFS_H$/;"	d
__HybridMedLDA__objcokus__	utils/objcokus.h	/^#define __HybridMedLDA__objcokus__$/;"	d
__OnlineTopic__Corpus__	Corpus.h	/^#define __OnlineTopic__Corpus__$/;"	d
__OnlineTopic__MVGaussian__	utils/MVGaussian.h	/^#define __OnlineTopic__MVGaussian__$/;"	d
__OnlineTopic__utils__	utils/utils.h	/^#define __OnlineTopic__utils__$/;"	d
___paMedLDA__paMedLDAgibbs__	paMedLDA-ave.h	/^#define ___paMedLDA__paMedLDAgibbs__$/;"	d
__paMedLDA__array__	utils/Array.h	/^#define __paMedLDA__array__$/;"	d
_cholesky_h	utils/cholesky.h	/^#define _cholesky_h$/;"	d
_dadd1	utils/ap.cpp	/^typedef void    (*_dadd1)(const double*, const double*, long);$/;"	t	file:
_dadds1	utils/ap.cpp	/^typedef void    (*_dadds1)(const double*, const double*, long, double);$/;"	t	file:
_ddot1	utils/ap.cpp	/^typedef double  (*_ddot1)(const double*, const double*, long);$/;"	t	file:
_dmove1	utils/ap.cpp	/^typedef void    (*_dmove1)(const double*, const double*, long);$/;"	t	file:
_dmoveneg1	utils/ap.cpp	/^typedef void    (*_dmoveneg1)(const double*, const double*, long);$/;"	t	file:
_dmoves1	utils/ap.cpp	/^typedef void    (*_dmoves1)(const double*, const double*, long, double);$/;"	t	file:
_dmuls1	utils/ap.cpp	/^typedef void    (*_dmuls1)(const double*, long, double);$/;"	t	file:
_dsub1	utils/ap.cpp	/^typedef void    (*_dsub1)(const double*, const double*, long);$/;"	t	file:
_spdinverse_h	utils/spdinverse.h	/^#define _spdinverse_h$/;"	d
_vadd	utils/apvt.h	/^void _vadd(T *vdst, const T *vsrc, int N)$/;"	f
_vadd	utils/apvt.h	/^void _vadd(T *vdst, const T *vsrc, int N, T2 alpha)$/;"	f
_vdotproduct	utils/apvt.h	/^T _vdotproduct(const T *v1, const T *v2, int N)$/;"	f
_vmove	utils/apvt.h	/^void _vmove(T *vdst, const T *vsrc, int N, T2 alpha)$/;"	f
_vmove	utils/apvt.h	/^void _vmove(T *vdst, const T* vsrc, int N)$/;"	f
_vmoveneg	utils/apvt.h	/^void _vmoveneg(T *vdst, const T *vsrc, int N)$/;"	f
_vmul	utils/apvt.h	/^void _vmul(T *vdst, int N, T2 alpha)$/;"	f
_vsub	utils/apvt.h	/^void _vsub(T *vdst, const T *vsrc, int N)$/;"	f
_vsub	utils/apvt.h	/^void _vsub(T *vdst, const T *vsrc, int N, T2 alpha)$/;"	f
abscomplex	utils/ap.cpp	/^const double ap::abscomplex(const ap::complex &z)$/;"	f	class:ap
accuracy	paMedLDA-ave.h	/^		double time, ob_percent, accuracy;$/;"	m	struct:paMedLDA_averaging::__anon3
afree	utils/ap.cpp	/^void ap::afree(void *block)$/;"	f	class:ap
alpha	paMedLDA-ave.h	/^		double alpha, beta, train_time;$/;"	m	class:paMedLDA_averaging::paMedLDAave
amalloc	utils/ap.cpp	/^void* ap::amalloc(size_t size, size_t alignment)$/;"	f	class:ap
ap	utils/ap.h	/^namespace ap$/;"	n
ap	utils/apaux.h	/^namespace ap {$/;"	n
ap_error	utils/ap.h	/^    ap_error(){};$/;"	f	class:ap::ap_error
ap_error	utils/ap.h	/^    ap_error(const char *s){ msg = s; };$/;"	f	class:ap::ap_error
ap_error	utils/ap.h	/^class ap_error$/;"	c	namespace:ap
array1d	paMedLDA-ave.h	/^		std::vector<T*>  array1d;$/;"	m	class:paMedLDA_averaging::Array
array1d	utils/Array.h	/^	std::vector<T*>  array1d;$/;"	m	class:Array
array1d	utils/utils.h	/^static T* array1d(int d1) {$/;"	f
array1d_del	utils/utils.h	/^static void array1d_del(T* array) {$/;"	f
array2d	paMedLDA-ave.h	/^		std::vector<T**> array2d;$/;"	m	class:paMedLDA_averaging::Array
array2d	utils/Array.h	/^	std::vector<T**> array2d;$/;"	m	class:Array
array2d	utils/utils.h	/^static T** array2d(int d1, int d2) {$/;"	f
array2d_del	utils/utils.h	/^static void array2d_del(T** array, int d1) {$/;"	f
array2d_dim	paMedLDA-ave.h	/^		std::vector<int> array2d_dim;$/;"	m	class:paMedLDA_averaging::Array
array2d_dim	utils/Array.h	/^	std::vector<int> array2d_dim;$/;"	m	class:Array
beta	paMedLDA-ave.h	/^		double alpha, beta, train_time;$/;"	m	class:paMedLDA_averaging::paMedLDAave
boolean_1d_array	utils/ap.h	/^typedef template_1d_array<bool>         boolean_1d_array;$/;"	t	namespace:ap
boolean_2d_array	utils/ap.h	/^typedef template_2d_array<bool>         boolean_2d_array;$/;"	t	namespace:ap
burnin	paMedLDA-ave.h	/^		int burnin, burnin_test, samplen_test;$/;"	m	class:paMedLDA_averaging::paMedLDAave
burnin_test	paMedLDA-ave.h	/^		int burnin, burnin_test, samplen_test;$/;"	m	class:paMedLDA_averaging::paMedLDAave
category	paMedLDA-ave.h	/^		int category;$/;"	m	class:paMedLDA_averaging::paMedLDAave
choleskydec	utils/MVGaussian.cpp	/^bool MVGaussian::choleskydec(double **A, double **res, const int &n, bool isupper)$/;"	f	class:MVGaussian
choleskydec	utils/utils.h	/^static bool choleskydec(double **A, double **res, const int &n, bool isupper)$/;"	f
choleskydecomposition	utils/cholesky.cpp	/^bool choleskydecomposition(ap::real_2d_array& a, int n, bool isupper)$/;"	f
clock_gettime	utils/utils.h	/^static int clock_gettime(struct timespec* t) {$/;"	f
cokus	paMedLDA-ave.h	/^		objcokus cokus;$/;"	m	class:paMedLDA_averaging::paMedLDAave
cokus	utils/InverseGaussian.h	/^	objcokus cokus;$/;"	m	class:InverseGaussian
cokus	utils/MVGaussian.h	/^	objcokus cokus;$/;"	m	class:MVGaussian
commitTestError	utils/utils.h	/^static void commitTestError( FILE** testErrorFile, double id, double accuracy) {$/;"	f
commit_point_n	paMedLDA-ave.h	/^		int commit_point_spacing, commit_point_n;		$/;"	m	class:paMedLDA_averaging::paMedLDAave
commit_point_spacing	paMedLDA-ave.h	/^		int commit_point_spacing, commit_point_n;		$/;"	m	class:paMedLDA_averaging::paMedLDAave
commit_points	paMedLDA-ave.h	/^		vector<Commit> commit_points;$/;"	m	class:paMedLDA_averaging::paMedLDAave
complex	utils/ap.h	/^    complex():x(0.0),y(0.0){};$/;"	f	class:ap::complex
complex	utils/ap.h	/^    complex(const complex &z):x(z.x),y(z.y){};$/;"	f	class:ap::complex
complex	utils/ap.h	/^    complex(const double &_x):x(_x),y(0.0){};$/;"	f	class:ap::complex
complex	utils/ap.h	/^    complex(const double &_x, const double &_y):x(_x),y(_y){};$/;"	f	class:ap::complex
complex	utils/ap.h	/^class complex$/;"	c	namespace:ap
complex_1d_array	utils/ap.h	/^typedef template_1d_array<complex>      complex_1d_array;$/;"	t	namespace:ap
complex_2d_array	utils/ap.h	/^typedef template_2d_array<complex>      complex_2d_array;$/;"	t	namespace:ap
conj	utils/ap.cpp	/^const ap::complex ap::conj(const ap::complex &z)$/;"	f	class:ap
const_raw_vector	utils/apvt.h	/^    const_raw_vector(const T *Data, int Length, int Step):$/;"	f	class:const_raw_vector
const_raw_vector	utils/apvt.h	/^class const_raw_vector$/;"	c
corpus	paMedLDA-ave.h	/^		Corpus* corpus;$/;"	m	class:paMedLDA_averaging::paMedLDAave
countFiles	utils/utils.h	/^static int countFiles( string directory) {$/;"	f
csqr	utils/ap.cpp	/^const ap::complex ap::csqr(const ap::complex &z)$/;"	f	class:ap
dadd1	utils/ap.cpp	/^static _dadd1     dadd1     = ABLAS==NULL ? NULL :     (_dadd1)  GetProcAddress(ABLAS, "ASMAdd1");$/;"	v	file:
dadds1	utils/ap.cpp	/^static _dadds1    dadds1    = ABLAS==NULL ? NULL :    (_dadds1)  GetProcAddress(ABLAS, "ASMAddS1");$/;"	v	file:
ddot1	utils/ap.cpp	/^static _ddot1     ddot1     = ABLAS==NULL ? NULL :     (_ddot1)  GetProcAddress(ABLAS, "ASMDotProduct1");$/;"	v	file:
debug	utils/debug.h	/^static bool debug( char* message, ...) {$/;"	f
debug_indent	utils/debug.h	/^static void debug_indent() {$/;"	f
debug_indentation	utils/debug.h	/^static int debug_indentation = 0;$/;"	v
debug_unindent	utils/debug.h	/^static void debug_unindent() {$/;"	f
del_1d	paMedLDA-ave.cpp	/^void Array<T>::del_1d(T* array) {$/;"	f	class:Array
del_2d	paMedLDA-ave.cpp	/^void Array<T>::del_2d(T** array, int d1) {$/;"	f	class:Array
digamma	utils/utils.h	/^static double digamma(double x) {$/;"	f
discriminant	paMedLDA-ave.cpp	/^double paMedLDAave::discriminant(double* weight, double* cd, double norm) {$/;"	f	class:paMedLDAave
dmove1	utils/ap.cpp	/^static _dmove1    dmove1    = ABLAS==NULL ? NULL :    (_dmove1)  GetProcAddress(ABLAS, "ASMMove1");$/;"	v	file:
dmoveneg1	utils/ap.cpp	/^static _dmoveneg1 dmoveneg1 = ABLAS==NULL ? NULL : (_dmoveneg1)  GetProcAddress(ABLAS, "ASMMoveNeg1");$/;"	v	file:
dmoves1	utils/ap.cpp	/^static _dmoves1   dmoves1   = ABLAS==NULL ? NULL :   (_dmoves1)  GetProcAddress(ABLAS, "ASMMoveS1");$/;"	v	file:
dmuls1	utils/ap.cpp	/^static _dmuls1    dmuls1    = ABLAS==NULL ? NULL :     (_dmuls1) GetProcAddress(ABLAS, "ASMMulS1");$/;"	v	file:
doc	Corpus.h	/^	Document* doc; 			\/\/ documents.$/;"	m	struct:__anon2
dotprod	utils/utils.h	/^static double dotprod( double* veca, double* vecb, int spaceK) {$/;"	f
dsub1	utils/ap.cpp	/^static _dsub1     dsub1     = ABLAS==NULL ? NULL :     (_dsub1)  GetProcAddress(ABLAS, "ASMSub1");$/;"	v	file:
eye	utils/apaux.h	/^	static real_2d_array* eye( int n) {$/;"	f	namespace:ap
free2d	utils/utils.h	/^static void free2d( T** m, int n) {$/;"	f
gamma	paMedLDA-ave.h	/^		double **gamma, **prev_gamma, **stat_gamma;;$/;"	m	class:paMedLDA_averaging::GlobalSample
gammasum	paMedLDA-ave.h	/^		double *gammasum; $/;"	m	class:paMedLDA_averaging::GlobalSample
getcolumn	utils/ap.h	/^    const_raw_vector<T> getcolumn(int iColumn, int iRowStart, int iRowEnd) const$/;"	f	class:ap::template_2d_array
getcolumn	utils/ap.h	/^    raw_vector<T> getcolumn(int iColumn, int iRowStart, int iRowEnd)$/;"	f	class:ap::template_2d_array
getcontent	utils/ap.h	/^    T* getcontent()$/;"	f	class:ap::template_1d_array
getcontent	utils/ap.h	/^    const T* getcontent() const$/;"	f	class:ap::template_1d_array
gethighbound	utils/ap.h	/^    int gethighbound(int iBoundNum = 0) const$/;"	f	class:ap::template_1d_array
gethighbound	utils/ap.h	/^    int gethighbound(int iBoundNum) const$/;"	f	class:ap::template_2d_array
getlowbound	utils/ap.h	/^    int getlowbound(int iBoundNum = 0) const$/;"	f	class:ap::template_1d_array
getlowbound	utils/ap.h	/^    int getlowbound(int iBoundNum) const$/;"	f	class:ap::template_2d_array
getrow	utils/ap.h	/^    const_raw_vector<T> getrow(int iRow, int iColumnStart, int iColumnEnd) const$/;"	f	class:ap::template_2d_array
getrow	utils/ap.h	/^    raw_vector<T> getrow(int iRow, int iColumnStart, int iColumnEnd)$/;"	f	class:ap::template_2d_array
getvector	utils/ap.h	/^    const_raw_vector<T> getvector(int iStart, int iEnd) const$/;"	f	class:ap::template_1d_array
getvector	utils/ap.h	/^    raw_vector<T> getvector(int iStart, int iEnd)$/;"	f	class:ap::template_1d_array
global	paMedLDA-ave.h	/^		GlobalSample *global;$/;"	m	class:paMedLDA_averaging::paMedLDAave
hiBit	utils/objcokus.h	/^#define hiBit(/;"	d
iLength	utils/apvt.h	/^    int     iLength, iStep;$/;"	m	class:const_raw_vector
iStep	utils/apvt.h	/^    int     iLength, iStep;$/;"	m	class:const_raw_vector
iceil	utils/ap.cpp	/^int ap::iceil(double x)$/;"	f	class:ap
ifloor	utils/ap.cpp	/^int ap::ifloor(double x)$/;"	f	class:ap
inferGamma	paMedLDA-ave.cpp	/^void paMedLDAave::inferGamma(int idx, bool reset) {$/;"	f	class:paMedLDAave
inference	paMedLDA-ave.cpp	/^double paMedLDAave::inference(CorpusData* testData) {$/;"	f	class:paMedLDAave
init	paMedLDA-ave.cpp	/^void paMedLDAave::init() {$/;"	f	class:paMedLDAave
integer_1d_array	utils/ap.h	/^typedef template_1d_array<int>          integer_1d_array;$/;"	t	namespace:ap
integer_2d_array	utils/ap.h	/^typedef template_2d_array<int>          integer_2d_array;$/;"	t	namespace:ap
inverse_cholydec	utils/utils.h	/^static void inverse_cholydec(double **A, double **res, double **lowerTriangle, const int &n)$/;"	f
inversecholesky	utils/spdinverse.cpp	/^bool inversecholesky(ap::real_2d_array& a, int n, bool isupper)$/;"	f
inversesymmetricpositivedefinite	utils/spdinverse.cpp	/^bool inversesymmetricpositivedefinite(ap::real_2d_array& a,$/;"	f
invg_sampler	paMedLDA-ave.h	/^		InverseGaussian invg_sampler;$/;"	m	class:paMedLDA_averaging::paMedLDAave
label_n	Corpus.h	/^	int label_n;				\/\/ number of labels.$/;"	m	struct:__anon1
left	utils/objcokus.h	/^	int      left;      \/\/ can *next++ this many times before reloading$/;"	m	class:objcokus
lets_batch	paMedLDA-ave.h	/^		bool lets_batch, lets_multic, lets_commit;$/;"	m	class:paMedLDA_averaging::paMedLDAave
lets_commit	paMedLDA-ave.h	/^		bool lets_batch, lets_multic, lets_commit;$/;"	m	class:paMedLDA_averaging::paMedLDAave
lets_multic	paMedLDA-ave.h	/^		bool lets_batch, lets_multic, lets_commit;$/;"	m	class:paMedLDA_averaging::paMedLDAave
loBit	utils/objcokus.h	/^#define loBit(/;"	d
loBits	utils/objcokus.h	/^#define loBits(/;"	d
loadDataDocument	Corpus.cpp	/^bool Corpus::loadDataDocument(FILE* fpin, Document &doc) {$/;"	f	class:Corpus
loadDataGML	Corpus.cpp	/^bool Corpus::loadDataGML(string train_file_path, string test_file_path, bool multi_task) {$/;"	f	class:Corpus
local_test	paMedLDA-ave.h	/^		LocalSample *local_train, *local_test;$/;"	m	class:paMedLDA_averaging::paMedLDAave
local_train	paMedLDA-ave.h	/^		LocalSample *local_train, *local_test;$/;"	m	class:paMedLDA_averaging::paMedLDAave
m_I	paMedLDA-ave.h	/^		int m_K, m_T, m_I, m_J, m_Jburnin, m_category; $/;"	m	class:paMedLDA_averaging::paMedLDAave
m_J	paMedLDA-ave.h	/^		int m_K, m_T, m_I, m_J, m_Jburnin, m_category; $/;"	m	class:paMedLDA_averaging::paMedLDAave
m_Jburnin	paMedLDA-ave.h	/^		int m_K, m_T, m_I, m_J, m_Jburnin, m_category; $/;"	m	class:paMedLDA_averaging::paMedLDAave
m_K	paMedLDA-ave.h	/^		int m_K, m_T, m_I, m_J, m_Jburnin, m_category; $/;"	m	class:paMedLDA_averaging::paMedLDAave
m_T	Corpus.h	/^	int m_T;  						\/\/ total number of different words.$/;"	m	class:Corpus
m_T	paMedLDA-ave.h	/^		int m_K, m_T, m_I, m_J, m_Jburnin, m_category; $/;"	m	class:paMedLDA_averaging::paMedLDAave
m_Vec	utils/ap.h	/^    T           *m_Vec;$/;"	m	class:ap::template_2d_array
m_Vec	utils/ap.h	/^    T         *m_Vec;$/;"	m	class:ap::template_1d_array
m_batchsize	paMedLDA-ave.h	/^		int m_epoch, m_batchsize;		$/;"	m	class:paMedLDA_averaging::paMedLDAave
m_c	paMedLDA-ave.h	/^		double m_c, m_l, m_v; $/;"	m	class:paMedLDA_averaging::paMedLDAave
m_category	paMedLDA-ave.h	/^		int m_K, m_T, m_I, m_J, m_Jburnin, m_category; $/;"	m	class:paMedLDA_averaging::paMedLDAave
m_dGset	utils/InverseGaussian.h	/^	double m_dGset;$/;"	m	class:InverseGaussian
m_dGset	utils/MVGaussian.h	/^	double m_dGset;$/;"	m	class:MVGaussian
m_dMu	utils/InverseGaussian.h	/^	double m_dMu;$/;"	m	class:InverseGaussian
m_dScale	utils/InverseGaussian.h	/^	double m_dScale;$/;"	m	class:InverseGaussian
m_epoch	paMedLDA-ave.h	/^		int m_epoch, m_batchsize;		$/;"	m	class:paMedLDA_averaging::paMedLDAave
m_iConstOffset	utils/ap.h	/^    long        m_iConstOffset, m_iLinearMember;$/;"	m	class:ap::template_2d_array
m_iHigh	utils/ap.h	/^    long      m_iLow, m_iHigh;$/;"	m	class:ap::template_1d_array
m_iHigh1	utils/ap.h	/^    long        m_iLow1, m_iLow2, m_iHigh1, m_iHigh2;$/;"	m	class:ap::template_2d_array
m_iHigh2	utils/ap.h	/^    long        m_iLow1, m_iLow2, m_iHigh1, m_iHigh2;$/;"	m	class:ap::template_2d_array
m_iLinearMember	utils/ap.h	/^    long        m_iConstOffset, m_iLinearMember;$/;"	m	class:ap::template_2d_array
m_iLow	utils/ap.h	/^    long      m_iLow, m_iHigh;$/;"	m	class:ap::template_1d_array
m_iLow1	utils/ap.h	/^    long        m_iLow1, m_iLow2, m_iHigh1, m_iHigh2;$/;"	m	class:ap::template_2d_array
m_iLow2	utils/ap.h	/^    long        m_iLow1, m_iLow2, m_iHigh1, m_iHigh2;$/;"	m	class:ap::template_2d_array
m_iSet	utils/InverseGaussian.h	/^	int m_iSet;$/;"	m	class:InverseGaussian
m_iSet	utils/MVGaussian.h	/^	int m_iSet;$/;"	m	class:MVGaussian
m_iVecSize	utils/ap.h	/^    long        m_iVecSize;$/;"	m	class:ap::template_2d_array
m_iVecSize	utils/ap.h	/^    long      m_iVecSize;$/;"	m	class:ap::template_1d_array
m_l	paMedLDA-ave.h	/^		double m_c, m_l, m_v; $/;"	m	class:paMedLDA_averaging::paMedLDAave
m_v	paMedLDA-ave.h	/^		double m_c, m_l, m_v; $/;"	m	class:paMedLDA_averaging::paMedLDAave
machineepsilon	utils/ap.cpp	/^const double ap::machineepsilon = 5E-16;$/;"	m	class:ap	file:
main	main.cpp	/^int main(int argc, const char * argv[])$/;"	f
make_assertion	utils/ap.h	/^    static void make_assertion(bool bClause)$/;"	f	class:ap::ap_error
make_assertion	utils/ap.h	/^    static void make_assertion(bool bClause, const char *msg)$/;"	f	class:ap::ap_error
maxint	utils/ap.cpp	/^int ap::maxint(int m1, int m2)$/;"	f	class:ap
maxreal	utils/ap.cpp	/^double ap::maxreal(double m1, double m2)$/;"	f	class:ap
maxrealnumber	utils/ap.cpp	/^const double ap::maxrealnumber  = 1E300;$/;"	m	class:ap	file:
mem_double	paMedLDA-ave.h	/^		Array<double> mem_double;$/;"	m	class:paMedLDA_averaging::paMedLDAave
mem_int	paMedLDA-ave.h	/^		Array<int> mem_int;$/;"	m	class:paMedLDA_averaging::paMedLDAave
minint	utils/ap.cpp	/^int ap::minint(int m1, int m2)$/;"	f	class:ap
minreal	utils/ap.cpp	/^double ap::minreal(double m1, double m2)$/;"	f	class:ap
minrealnumber	utils/ap.cpp	/^const double ap::minrealnumber  = 1E-300;$/;"	m	class:ap	file:
mixBits	utils/objcokus.h	/^#define mixBits(/;"	d
msg	utils/ap.h	/^    std::string msg;$/;"	m	class:ap::ap_error
multi_label	Corpus.h	/^	bool multi_label;				\/\/ is this a multi-label corpus.$/;"	m	class:Corpus
mvGaussian_sampler	paMedLDA-ave.h	/^		MVGaussian mvGaussian_sampler;$/;"	m	class:paMedLDA_averaging::paMedLDAave
my	Corpus.h	/^	double *my; 				\/\/ predicted label with confidence.$/;"	m	struct:__anon1
my	paMedLDA-ave.h	/^		double* my;$/;"	m	struct:paMedLDA_averaging::__anon3
myrand	utils/defs.h	/^#define myrand(/;"	d
nd	Corpus.h	/^	int nd;						\/\/ number of words in the document.$/;"	m	struct:__anon1
new_1d	paMedLDA-ave.cpp	/^T* Array<T>::new_1d(int d1) {$/;"	f	class:Array
new_2d	paMedLDA-ave.cpp	/^T** Array<T>::new_2d(int d1, int d2) {$/;"	f	class:Array
new_2d	paMedLDA-ave.cpp	/^T** Array<T>::new_2d(int d1, int* w2) {$/;"	f	class:Array
newsgroup_n	Corpus.h	/^	int newsgroup_n; 				\/\/ total number of newsgroups.$/;"	m	class:Corpus
next	utils/objcokus.h	/^	uint32   *next;          \/\/ next random value is computed from here$/;"	m	class:objcokus
nextGaussian	utils/InverseGaussian.cpp	/^double InverseGaussian::nextGaussian()$/;"	f	class:InverseGaussian
nextGaussian	utils/MVGaussian.cpp	/^double MVGaussian::nextGaussian()$/;"	f	class:MVGaussian
nextMVGaussian	utils/MVGaussian.cpp	/^void MVGaussian::nextMVGaussian(double *mean, double **precision, double *res, const int &n)$/;"	f	class:MVGaussian
nextMVGaussianWithCholesky	utils/MVGaussian.cpp	/^void MVGaussian::nextMVGaussianWithCholesky(double *mean, double **precisionLowerTriangular, double *res, const int &n)$/;"	f	class:MVGaussian
nextMVGaussianWithCholeskyAp	utils/MVGaussian.cpp	/^void MVGaussian::nextMVGaussianWithCholeskyAp(ap::real_2d_array& mean, ap::real_2d_array& precisionLowerTriangular, ap::real_2d_array& res) {$/;"	f	class:MVGaussian
normGamma	paMedLDA-ave.cpp	/^void paMedLDAave::normGamma(int N, bool remove) {$/;"	f	class:paMedLDAave
ob_percent	paMedLDA-ave.h	/^		double time, ob_percent, accuracy;$/;"	m	struct:paMedLDA_averaging::__anon3
objcokus	utils/objcokus.h	/^	objcokus()$/;"	f	class:objcokus
objcokus	utils/objcokus.h	/^class objcokus {$/;"	c
operator !=	utils/ap.cpp	/^const bool ap::operator!=(const ap::complex& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator ()	utils/ap.h	/^    T& operator()(int i)$/;"	f	class:ap::template_1d_array
operator ()	utils/ap.h	/^    T& operator()(int i1, int i2)$/;"	f	class:ap::template_2d_array
operator ()	utils/ap.h	/^    const T& operator()(int i) const$/;"	f	class:ap::template_1d_array
operator ()	utils/ap.h	/^    const T& operator()(int i1, int i2) const$/;"	f	class:ap::template_2d_array
operator *	utils/ap.cpp	/^const ap::complex ap::operator*(const ap::complex& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator *	utils/ap.cpp	/^const ap::complex ap::operator*(const ap::complex& lhs, const double& rhs)$/;"	f	class:ap
operator *	utils/ap.cpp	/^const ap::complex ap::operator*(const double& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator *	utils/ap.h	/^	template_2d_array<T,Aligned>& operator*( template_2d_array<T,Aligned>& b) {$/;"	f	class:ap::template_2d_array
operator *=	utils/ap.h	/^    complex& operator*=(const complex& z){ double t = x*z.x-y*z.y; y = x*z.y+y*z.x; x = t; return *this; };$/;"	f	class:ap::complex
operator *=	utils/ap.h	/^    complex& operator*=(const double& v){ x *= v; y *= v;  return *this; };$/;"	f	class:ap::complex
operator +	utils/ap.cpp	/^const ap::complex ap::operator+(const ap::complex& lhs)$/;"	f	class:ap
operator +	utils/ap.cpp	/^const ap::complex ap::operator+(const ap::complex& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator +	utils/ap.cpp	/^const ap::complex ap::operator+(const ap::complex& lhs, const double& rhs)$/;"	f	class:ap
operator +	utils/ap.cpp	/^const ap::complex ap::operator+(const double& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator +	utils/ap.h	/^	template_2d_array<T,Aligned>& operator+( template_2d_array<T,Aligned>& b) {$/;"	f	class:ap::template_2d_array
operator +=	utils/ap.h	/^    complex& operator+=(const complex& z){ x += z.x; y += z.y; return *this; };$/;"	f	class:ap::complex
operator +=	utils/ap.h	/^    complex& operator+=(const double& v){ x += v;          return *this; };$/;"	f	class:ap::complex
operator -	utils/ap.cpp	/^const ap::complex ap::operator-(const ap::complex& lhs)$/;"	f	class:ap
operator -	utils/ap.cpp	/^const ap::complex ap::operator-(const ap::complex& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator -	utils/ap.cpp	/^const ap::complex ap::operator-(const ap::complex& lhs, const double& rhs)$/;"	f	class:ap
operator -	utils/ap.cpp	/^const ap::complex ap::operator-(const double& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator -=	utils/ap.h	/^    complex& operator-=(const complex& z){ x -= z.x; y -= z.y; return *this; };$/;"	f	class:ap::complex
operator -=	utils/ap.h	/^    complex& operator-=(const double& v){ x -= v;          return *this; };$/;"	f	class:ap::complex
operator /	utils/ap.cpp	/^const ap::complex ap::operator\/(const ap::complex& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator /	utils/ap.cpp	/^const ap::complex ap::operator\/(const ap::complex& lhs, const double& rhs)$/;"	f	class:ap
operator /	utils/ap.cpp	/^const ap::complex ap::operator\/(const double& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator /=	utils/ap.h	/^    complex& operator\/=(const complex& z)$/;"	f	class:ap::complex
operator /=	utils/ap.h	/^    complex& operator\/=(const double& v){ x \/= v; y \/= v;  return *this; };$/;"	f	class:ap::complex
operator =	utils/ap.h	/^    complex& operator= (const complex& z){ x  = z.x; y  = z.y; return *this; };$/;"	f	class:ap::complex
operator =	utils/ap.h	/^    complex& operator= (const double& v){ x  = v; y = 0.0; return *this; };$/;"	f	class:ap::complex
operator =	utils/ap.h	/^    const template_1d_array& operator=(const template_1d_array &rhs)$/;"	f	class:ap::template_1d_array
operator =	utils/ap.h	/^    const template_2d_array& operator=(const template_2d_array &rhs)$/;"	f	class:ap::template_2d_array
operator ==	utils/ap.cpp	/^const bool ap::operator==(const ap::complex& lhs, const ap::complex& rhs)$/;"	f	class:ap
pData	utils/apvt.h	/^    T       *pData;$/;"	m	class:const_raw_vector
paMedLDA_averaging	paMedLDA-ave.h	/^namespace paMedLDA_averaging {$/;"	n
paMedLDAave	paMedLDA-ave.cpp	/^paMedLDAave::paMedLDAave(Corpus* corpus, int category) {$/;"	f	class:paMedLDAave
paMedLDAave	paMedLDA-ave.h	/^	class paMedLDAave {$/;"	c	namespace:paMedLDA_averaging
path	main.cpp	/^string path = "..\/..\/..\/data\/";$/;"	v
pi	utils/ap.cpp	/^double ap::pi()$/;"	f	class:ap
prev_gamma	paMedLDA-ave.h	/^		double **gamma, **prev_gamma, **stat_gamma;;$/;"	m	class:paMedLDA_averaging::GlobalSample
prev_gamma_list_end	paMedLDA-ave.h	/^		int *prev_gamma_list_k, *prev_gamma_list_t, prev_gamma_list_end;$/;"	m	class:paMedLDA_averaging::GlobalSample
prev_gamma_list_k	paMedLDA-ave.h	/^		int *prev_gamma_list_k, *prev_gamma_list_t, prev_gamma_list_end;$/;"	m	class:paMedLDA_averaging::GlobalSample
prev_gamma_list_t	paMedLDA-ave.h	/^		int *prev_gamma_list_k, *prev_gamma_list_t, prev_gamma_list_end;$/;"	m	class:paMedLDA_averaging::GlobalSample
prev_weight_mean	paMedLDA-ave.h	/^		double *weight_mean, *prev_weight_mean;$/;"	m	class:paMedLDA_averaging::GlobalSample
py	Corpus.h	/^	int *y, *py;				\/\/ label and predicted label (allow multi-task).$/;"	m	struct:__anon1
random01	utils/objcokus.h	/^	double random01() {$/;"	f	class:objcokus
randomMT	utils/objcokus.h	/^	uint32 randomMT(void)$/;"	f	class:objcokus
randominteger	utils/ap.cpp	/^int ap::randominteger(int maxv)$/;"	f	class:ap
randomreal	utils/ap.cpp	/^double ap::randomreal()$/;"	f	class:ap
raw_vector	utils/apvt.h	/^    raw_vector(T *Data, int Length, int Step):const_raw_vector<T>(Data, Length, Step){};$/;"	f	class:raw_vector
raw_vector	utils/apvt.h	/^class raw_vector : public const_raw_vector<T>$/;"	c
real_1d_array	utils/ap.h	/^typedef template_1d_array<double,true>  real_1d_array;$/;"	t	namespace:ap
real_2d_array	utils/ap.h	/^typedef template_2d_array<double,true>  real_2d_array;$/;"	t	namespace:ap
reloadMT	utils/objcokus.h	/^	uint32 reloadMT(void)$/;"	f	class:objcokus
reset	utils/InverseGaussian.h	/^	void reset(double dMu, double dScale) {$/;"	f	class:InverseGaussian
round	utils/ap.cpp	/^int ap::round(double x)$/;"	f	class:ap
sample	utils/InverseGaussian.cpp	/^double InverseGaussian::sample()$/;"	f	class:InverseGaussian
samplen_test	paMedLDA-ave.h	/^		int burnin, burnin_test, samplen_test;$/;"	m	class:paMedLDA_averaging::paMedLDAave
seedMT	utils/objcokus.h	/^	void seedMT(uint32 seed)$/;"	f	class:objcokus
setbounds	utils/ap.h	/^    void setbounds( int iLow, int iHigh )$/;"	f	class:ap::template_1d_array
setbounds	utils/ap.h	/^    void setbounds( int iLow1, int iHigh1, int iLow2, int iHigh2 )$/;"	f	class:ap::template_2d_array
setcontent	utils/ap.h	/^    void setcontent( int iLow, int iHigh, const T *pContent )$/;"	f	class:ap::template_1d_array
setcontent	utils/ap.h	/^    void setcontent( int iLow1, int iHigh1, int iLow2, int iHigh2, const T *pContent )$/;"	f	class:ap::template_2d_array
setshape	utils/ap.h	/^	void setshape( int iHigh1, int iHigh2) {$/;"	f	class:ap::template_2d_array
shape	utils/ap.h	/^	int shape( int dim) const {$/;"	f	class:ap::template_2d_array
shuffleArray	utils/utils.h	/^static void shuffleArray(type *idx, int D, int iteration = 1000) {$/;"	f
sign	utils/ap.cpp	/^int ap::sign(double x)$/;"	f	class:ap
sp_gamma	utils/utils.h	/^static double sp_gamma(double z)$/;"	f
spdmatrixcholesky	utils/cholesky.cpp	/^bool spdmatrixcholesky(ap::real_2d_array& a, int n, bool isupper)$/;"	f
spdmatrixcholeskyinverse	utils/spdinverse.cpp	/^bool spdmatrixcholeskyinverse(ap::real_2d_array& a, int n, bool isupper)$/;"	f
spdmatrixinverse	utils/spdinverse.cpp	/^bool spdmatrixinverse(ap::real_2d_array& a, int n, bool isupper)$/;"	f
splitWords	utils/utils.h	/^static list<int>* splitWords( string text, map<string,int>* dic) {$/;"	f
splitWords	utils/utils.h	/^static list<string>* splitWords( string text) {$/;"	f
sqr	utils/ap.cpp	/^double ap::sqr(double x)$/;"	f	class:ap
st_gamma	utils/utils.h	/^static double st_gamma(double x)$/;"	f
stat_gamma	paMedLDA-ave.h	/^		double **gamma, **prev_gamma, **stat_gamma;;$/;"	m	class:paMedLDA_averaging::GlobalSample
stat_gamma_list_end	paMedLDA-ave.h	/^		int *stat_gamma_list_k, *stat_gamma_list_t, stat_gamma_list_end; $/;"	m	class:paMedLDA_averaging::GlobalSample
stat_gamma_list_k	paMedLDA-ave.h	/^		int *stat_gamma_list_k, *stat_gamma_list_t, stat_gamma_list_end; $/;"	m	class:paMedLDA_averaging::GlobalSample
stat_gamma_list_t	paMedLDA-ave.h	/^		int *stat_gamma_list_k, *stat_gamma_list_t, stat_gamma_list_end; $/;"	m	class:paMedLDA_averaging::GlobalSample
state	utils/objcokus.h	/^	uint32   state[MT_NT+1];     \/\/ state vector + 1 extra to not violate ANSI C$/;"	m	class:objcokus
tau	paMedLDA-ave.h	/^		double *tau;					\/\/ solution of the dual problem.$/;"	m	class:paMedLDA_averaging::LocalSample
template_1d_array	utils/ap.h	/^    template_1d_array()$/;"	f	class:ap::template_1d_array
template_1d_array	utils/ap.h	/^    template_1d_array(const template_1d_array &rhs)$/;"	f	class:ap::template_1d_array
template_1d_array	utils/ap.h	/^class template_1d_array$/;"	c	namespace:ap
template_2d_array	utils/ap.h	/^    template_2d_array()$/;"	f	class:ap::template_2d_array
template_2d_array	utils/ap.h	/^    template_2d_array(const template_2d_array &rhs)$/;"	f	class:ap::template_2d_array
template_2d_array	utils/ap.h	/^class template_2d_array$/;"	c	namespace:ap
test_acc	paMedLDA-ave.h	/^		double test_acc;$/;"	m	class:paMedLDA_averaging::paMedLDAave
test_data	Corpus.h	/^	CorpusData train_data, test_data;$/;"	m	class:Corpus
test_data	paMedLDA-ave.h	/^		CorpusData *train_data, *test_data;$/;"	m	class:paMedLDA_averaging::paMedLDAave
time	paMedLDA-ave.h	/^		double time, ob_percent, accuracy;$/;"	m	struct:paMedLDA_averaging::__anon3
toLowerCase	utils/utils.h	/^static string toLowerCase( string str) {$/;"	f
train	paMedLDA-ave.cpp	/^double paMedLDAave::train() {$/;"	f	class:paMedLDAave
train_data	Corpus.h	/^	CorpusData train_data, test_data;$/;"	m	class:Corpus
train_data	paMedLDA-ave.h	/^		CorpusData *train_data, *test_data;$/;"	m	class:paMedLDA_averaging::paMedLDAave
train_time	paMedLDA-ave.h	/^		double alpha, beta, train_time;$/;"	m	class:paMedLDA_averaging::paMedLDAave
trans	utils/ap.h	/^	template_2d_array<T,Aligned>& trans() {$/;"	f	class:ap::template_2d_array
trunc	utils/ap.cpp	/^int ap::trunc(double x)$/;"	f	class:ap
uint32	utils/objcokus.h	/^typedef unsigned long uint32;$/;"	t
updateWeight	paMedLDA-ave.cpp	/^void paMedLDAave::updateWeight(int idx, int N, bool remove) {$/;"	f	class:paMedLDAave
updateZ	paMedLDA-ave.cpp	/^void paMedLDAave::updateZ(int idx) {$/;"	f	class:paMedLDAave
updateZTest	paMedLDA-ave.cpp	/^void paMedLDAave::updateZTest() {$/;"	f	class:paMedLDAave
vadd	utils/ap.cpp	/^void ap::vadd(ap::complex *vdst, const ap::complex *vsrc, int N)$/;"	f	class:ap
vadd	utils/ap.cpp	/^void ap::vadd(ap::complex *vdst, const ap::complex *vsrc, int N, ap::complex alpha)$/;"	f	class:ap
vadd	utils/ap.cpp	/^void ap::vadd(ap::complex *vdst, const ap::complex *vsrc, int N, double alpha)$/;"	f	class:ap
vadd	utils/ap.cpp	/^void ap::vadd(double *vdst, const double *vsrc, int N)$/;"	f	class:ap
vadd	utils/ap.cpp	/^void ap::vadd(double *vdst, const double *vsrc, int N, double alpha)$/;"	f	class:ap
vadd	utils/apvt.h	/^void vadd(raw_vector<T> vdst, const_raw_vector<T> vsrc)$/;"	f
vadd	utils/apvt.h	/^void vadd(raw_vector<T> vdst, const_raw_vector<T> vsrc, T2 alpha)$/;"	f
vdotproduct	utils/ap.cpp	/^ap::complex ap::vdotproduct(const ap::complex *v1, const ap::complex *v2, int N)$/;"	f	class:ap
vdotproduct	utils/ap.cpp	/^double ap::vdotproduct(const double *v1, const double *v2, int N)$/;"	f	class:ap
vdotproduct	utils/apvt.h	/^T vdotproduct(const_raw_vector<T> v1, const_raw_vector<T> v2)$/;"	f
vecabs	utils/utils.h	/^static void vecabs( double* veca, int spaceK) {$/;"	f
vecadd	utils/utils.h	/^static void vecadd( double* veca, double* vecb, int spaceK) {$/;"	f
vecdivs	utils/utils.h	/^static void vecdivs( double* veca, double x, int spaceK) {$/;"	f
vecmul	utils/utils.h	/^static void vecmul( double* veca, double* vecb, int spaceK) {$/;"	f
vecmuls	utils/utils.h	/^static void vecmuls( double* veca, double x, int spaceK) {$/;"	f
vecsqr	utils/utils.h	/^static void vecsqr( double* veca, int spaceK) {$/;"	f
vecsub	utils/utils.h	/^static void vecsub( double* veca, double* vecb, int spaceK) {$/;"	f
vecsubs	utils/utils.h	/^static void vecsubs( double* veca, double scalar, int spaceK) {$/;"	f
vecsum	utils/utils.h	/^static double vecsum( double* veca, int spaceK) {$/;"	f
visualize	utils/ap.h	/^	void visualize() {$/;"	f	class:ap::template_2d_array
visualize	utils/apaux.h	/^	static void visualize( real_2d_array& array) {$/;"	f	namespace:ap
vlen	utils/ap.cpp	/^int ap::vlen(int n1, int n2)$/;"	f	class:ap
vmove	utils/ap.cpp	/^void ap::vmove(ap::complex *vdst, const ap::complex *vsrc, int N, ap::complex alpha)$/;"	f	class:ap
vmove	utils/ap.cpp	/^void ap::vmove(ap::complex *vdst, const ap::complex *vsrc, int N, double alpha)$/;"	f	class:ap
vmove	utils/ap.cpp	/^void ap::vmove(ap::complex *vdst, const ap::complex* vsrc, int N)$/;"	f	class:ap
vmove	utils/ap.cpp	/^void ap::vmove(double *vdst, const double *vsrc, int N, double alpha)$/;"	f	class:ap
vmove	utils/ap.cpp	/^void ap::vmove(double *vdst, const double* vsrc, int N)$/;"	f	class:ap
vmove	utils/apvt.h	/^void vmove(raw_vector<T> vdst, const_raw_vector<T> vsrc)$/;"	f
vmove	utils/apvt.h	/^void vmove(raw_vector<T> vdst, const_raw_vector<T> vsrc, T2 alpha)$/;"	f
vmoveneg	utils/ap.cpp	/^void ap::vmoveneg(ap::complex *vdst, const ap::complex *vsrc, int N)$/;"	f	class:ap
vmoveneg	utils/ap.cpp	/^void ap::vmoveneg(double *vdst, const double *vsrc, int N)$/;"	f	class:ap
vmoveneg	utils/apvt.h	/^void vmoveneg(raw_vector<T> vdst, const_raw_vector<T> vsrc)$/;"	f
vmul	utils/ap.cpp	/^void ap::vmul(ap::complex *vdst, int N, ap::complex alpha)$/;"	f	class:ap
vmul	utils/ap.cpp	/^void ap::vmul(ap::complex *vdst, int N, double alpha)$/;"	f	class:ap
vmul	utils/ap.cpp	/^void ap::vmul(double *vdst, int N, double alpha)$/;"	f	class:ap
vmul	utils/apvt.h	/^void vmul(raw_vector<T> vdst, T2 alpha)$/;"	f
vsub	utils/ap.cpp	/^void ap::vsub(ap::complex *vdst, const ap::complex *vsrc, int N)$/;"	f	class:ap
vsub	utils/ap.cpp	/^void ap::vsub(ap::complex *vdst, const ap::complex *vsrc, int N, ap::complex alpha)$/;"	f	class:ap
vsub	utils/ap.cpp	/^void ap::vsub(ap::complex *vdst, const ap::complex *vsrc, int N, double alpha)$/;"	f	class:ap
vsub	utils/ap.cpp	/^void ap::vsub(double *vdst, const double *vsrc, int N)$/;"	f	class:ap
vsub	utils/ap.cpp	/^void ap::vsub(double *vdst, const double *vsrc, int N, double alpha)$/;"	f	class:ap
vsub	utils/apvt.h	/^void vsub(raw_vector<T> vdst, const_raw_vector<T> vsrc)$/;"	f
vsub	utils/apvt.h	/^void vsub(raw_vector<T> vdst, const_raw_vector<T> vsrc, T2 alpha)$/;"	f
weight_mean	paMedLDA-ave.h	/^		double *weight_mean, *prev_weight_mean;$/;"	m	class:paMedLDA_averaging::GlobalSample
words	Corpus.h	/^	int *words;					\/\/ words in the document.$/;"	m	struct:__anon1
wrongColumn	utils/ap.h	/^    bool wrongColumn(int j) const { return j<m_iLow2 || j>m_iHigh2; };$/;"	f	class:ap::template_2d_array
wrongIdx	utils/ap.h	/^    bool wrongIdx(int i) const { return i<m_iLow || i>m_iHigh; };$/;"	f	class:ap::template_1d_array
wrongRow	utils/ap.h	/^    bool wrongRow(int i) const { return i<m_iLow1 || i>m_iHigh1; };$/;"	f	class:ap::template_2d_array
x	utils/ap.h	/^    double x, y;$/;"	m	class:ap::complex
y	Corpus.h	/^	int *y, *py;				\/\/ label and predicted label (allow multi-task).$/;"	m	struct:__anon1
y	utils/ap.h	/^    double x, y;$/;"	m	class:ap::complex
zeros	utils/apaux.h	/^	static real_2d_array* zeros( int m, int n) {$/;"	f	namespace:ap
~Array	paMedLDA-ave.cpp	/^Array<T>::~Array() {$/;"	f	class:Array
~Corpus	Corpus.cpp	/^Corpus::~Corpus() {$/;"	f	class:Corpus
~InverseGaussian	utils/InverseGaussian.cpp	/^InverseGaussian::~InverseGaussian(void)$/;"	f	class:InverseGaussian
~MVGaussian	utils/MVGaussian.cpp	/^MVGaussian::~MVGaussian(void)$/;"	f	class:MVGaussian
~paMedLDAave	paMedLDA-ave.cpp	/^paMedLDAave::~paMedLDAave() {$/;"	f	class:paMedLDAave
~template_1d_array	utils/ap.h	/^    ~template_1d_array()$/;"	f	class:ap::template_1d_array
~template_2d_array	utils/ap.h	/^    ~template_2d_array()$/;"	f	class:ap::template_2d_array
