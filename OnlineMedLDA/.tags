!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ABLAS	src/utils/ap.cpp	/^HINSTANCE ABLAS = LoadLibrary("ablas.dll");$/;"	v
APVT_H	inc/utils/apvt.h	/^#define APVT_H$/;"	d
AP_ASSERT	inc/utils/ap.h	/^#define AP_ASSERT$/;"	d
AP_H	inc/utils/ap.h	/^#define AP_H$/;"	d
AP_UNKNOWN	inc/utils/ap.h	/^#define AP_UNKNOWN$/;"	d
ARCHITECTURE_ID	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^#  define ARCHITECTURE_ID /;"	d	file:
ARCHITECTURE_ID	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define ARCHITECTURE_ID /;"	d	file:
Array	inc/paMedLDAave.h	/^	class Array {$/;"	c	namespace:paMedLDA_averaging
Array	src/paMedLDAave.cpp	/^Array<T>::Array() {$/;"	f	class:Array
BOOST_PYTHON_MODULE	src/paMedLDAaveWrapper.cpp	/^BOOST_PYTHON_MODULE(libbayespa)$/;"	f
CLASSIFICATION	inc/paMedLDAave.h	/^	enum PAmode {CLASSIFICATION, REGRESSION};$/;"	e	enum:paMedLDA_averaging::PAmode
CMAKE_BINARY_DIR	Makefile	/^CMAKE_BINARY_DIR = "\/Volumes\/Universe\/Research\/Machine Learning\/BayesPA\/code release\/OnlineMedLDA"$/;"	m
CMAKE_BINARY_DIR	src/Makefile	/^CMAKE_BINARY_DIR = "\/Volumes\/Universe\/Research\/Machine Learning\/BayesPA\/code release\/OnlineMedLDA"$/;"	m
CMAKE_BINARY_DIR	src/utils/Makefile	/^CMAKE_BINARY_DIR = "\/Volumes\/Universe\/Research\/Machine Learning\/BayesPA\/code release\/OnlineMedLDA"$/;"	m
CMAKE_COMMAND	Makefile	/^CMAKE_COMMAND = \/opt\/local\/bin\/cmake$/;"	m
CMAKE_COMMAND	src/Makefile	/^CMAKE_COMMAND = \/opt\/local\/bin\/cmake$/;"	m
CMAKE_COMMAND	src/utils/Makefile	/^CMAKE_COMMAND = \/opt\/local\/bin\/cmake$/;"	m
CMAKE_EDIT_COMMAND	Makefile	/^CMAKE_EDIT_COMMAND = \/opt\/local\/bin\/ccmake$/;"	m
CMAKE_EDIT_COMMAND	src/Makefile	/^CMAKE_EDIT_COMMAND = \/opt\/local\/bin\/ccmake$/;"	m
CMAKE_EDIT_COMMAND	src/utils/Makefile	/^CMAKE_EDIT_COMMAND = \/opt\/local\/bin\/ccmake$/;"	m
CMAKE_SOURCE_DIR	Makefile	/^CMAKE_SOURCE_DIR = "\/Volumes\/Universe\/Research\/Machine Learning\/BayesPA\/code release\/OnlineMedLDA"$/;"	m
CMAKE_SOURCE_DIR	src/Makefile	/^CMAKE_SOURCE_DIR = "\/Volumes\/Universe\/Research\/Machine Learning\/BayesPA\/code release\/OnlineMedLDA"$/;"	m
CMAKE_SOURCE_DIR	src/utils/Makefile	/^CMAKE_SOURCE_DIR = "\/Volumes\/Universe\/Research\/Machine Learning\/BayesPA\/code release\/OnlineMedLDA"$/;"	m
COMPILER_ID	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^#   define COMPILER_ID /;"	d	file:
COMPILER_ID	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^#  define COMPILER_ID /;"	d	file:
COMPILER_ID	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^# define COMPILER_ID /;"	d	file:
COMPILER_ID	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#   define COMPILER_ID /;"	d	file:
COMPILER_ID	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define COMPILER_ID /;"	d	file:
COMPILER_ID	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define COMPILER_ID /;"	d	file:
COMPILER_VERSION_MAJOR	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^#  define COMPILER_VERSION_MAJOR /;"	d	file:
COMPILER_VERSION_MAJOR	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^# define COMPILER_VERSION_MAJOR /;"	d	file:
COMPILER_VERSION_MAJOR	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define COMPILER_VERSION_MAJOR /;"	d	file:
COMPILER_VERSION_MAJOR	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define COMPILER_VERSION_MAJOR /;"	d	file:
COMPILER_VERSION_MINOR	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^#  define COMPILER_VERSION_MINOR /;"	d	file:
COMPILER_VERSION_MINOR	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^# define COMPILER_VERSION_MINOR /;"	d	file:
COMPILER_VERSION_MINOR	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define COMPILER_VERSION_MINOR /;"	d	file:
COMPILER_VERSION_MINOR	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define COMPILER_VERSION_MINOR /;"	d	file:
COMPILER_VERSION_PATCH	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^#   define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^#  define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^# define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#   define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_TWEAK	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^#  define COMPILER_VERSION_TWEAK /;"	d	file:
COMPILER_VERSION_TWEAK	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define COMPILER_VERSION_TWEAK /;"	d	file:
COST_PARAMETER	inc/utils/defs.h	/^#define COST_PARAMETER /;"	d
Cdk	inc/paMedLDAave.h	/^		double **Cdk, **Ckt;$/;"	m	class:paMedLDA_averaging::LocalSample
Ckt	inc/paMedLDAave.h	/^		double **Cdk, **Ckt;$/;"	m	class:paMedLDA_averaging::LocalSample
Ckt_sum	inc/paMedLDAave.h	/^		double *Ckt_sum;$/;"	m	class:paMedLDA_averaging::LocalSample
Commit	inc/paMedLDAave.h	/^	}Commit;$/;"	t	namespace:paMedLDA_averaging	typeref:struct:paMedLDA_averaging::__anon3
Corpus	inc/Corpus.h	/^class Corpus {$/;"	c
Corpus	src/Corpus.cpp	/^Corpus::Corpus() {$/;"	f	class:Corpus
CorpusData	inc/Corpus.h	/^}CorpusData;$/;"	t	typeref:struct:__anon2
D	inc/Corpus.h	/^	int D;						\/\/ total number of documents.$/;"	m	struct:__anon2
DEBUG_PRINT	inc/utils/debug.h	/^#define DEBUG_PRINT /;"	d
DEC	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^#define DEC(/;"	d	file:
DEC	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#define DEC(/;"	d	file:
Document	inc/Corpus.h	/^}Document;$/;"	t	typeref:struct:__anon1
EQUALS	Makefile	/^EQUALS = =$/;"	m
EQUALS	src/Makefile	/^EQUALS = =$/;"	m
EQUALS	src/utils/Makefile	/^EQUALS = =$/;"	m
GEN_BIN_LABEL	src/paMedLDAave.cpp	/^#define GEN_BIN_LABEL(/;"	d	file:
GetData	inc/utils/apvt.h	/^    T* GetData()$/;"	f	class:raw_vector
GetData	inc/utils/apvt.h	/^    const T* GetData() const$/;"	f	class:const_raw_vector
GetLength	inc/utils/apvt.h	/^    int GetLength() const$/;"	f	class:const_raw_vector
GetStep	inc/utils/apvt.h	/^    int GetStep() const$/;"	f	class:const_raw_vector
GlobalSample	inc/paMedLDAave.h	/^	class GlobalSample {$/;"	c	namespace:paMedLDA_averaging
GlobalSample	src/paMedLDAave.cpp	/^GlobalSample::GlobalSample(paMedLDAave* medlda){$/;"	f	class:GlobalSample
HEX	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^#define HEX(/;"	d	file:
HEX	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#define HEX(/;"	d	file:
ID_VOID_MAIN	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^# define ID_VOID_MAIN$/;"	d	file:
INVMVGAUSSIAN_H	inc/utils/InverseGaussian.h	/^#define INVMVGAUSSIAN_H$/;"	d
InverseGaussian	inc/utils/InverseGaussian.h	/^	InverseGaussian(double dMu, double dScale) {$/;"	f	class:InverseGaussian
InverseGaussian	inc/utils/InverseGaussian.h	/^class InverseGaussian$/;"	c
InverseGaussian	src/utils/InverseGaussian.cpp	/^InverseGaussian::InverseGaussian(void)$/;"	f	class:InverseGaussian
LocalSample	inc/paMedLDAave.h	/^	class LocalSample {$/;"	c	namespace:paMedLDA_averaging
LocalSample	src/paMedLDAave.cpp	/^LocalSample::LocalSample(paMedLDAave* medlda, CorpusData* data) {$/;"	f	class:LocalSample
MIN_GIBBS_ITERATION	inc/utils/defs.h	/^#define MIN_GIBBS_ITERATION /;"	d
MT_K	inc/utils/objcokus.h	/^#define MT_K /;"	d
MT_M	inc/utils/objcokus.h	/^#define MT_M /;"	d
MT_NT	inc/utils/objcokus.h	/^#define MT_NT /;"	d
MVGaussian	inc/utils/MVGaussian.h	/^class MVGaussian$/;"	c
MVGaussian	src/utils/MVGaussian.cpp	/^MVGaussian::MVGaussian(void)$/;"	f	class:MVGaussian
NO_AP_ASSERT	inc/utils/ap.h	/^#define NO_AP_ASSERT /;"	d
NO_AP_ASSERT	inc/utils/ap.h	/^#undef NO_AP_ASSERT /;"	d
NUMERICAL_ZERO	inc/utils/defs.h	/^#define NUMERICAL_ZERO /;"	d
OVERFLOW_THREHOLD	inc/utils/defs.h	/^#define OVERFLOW_THREHOLD /;"	d
OnlineTopic_apaux_h	inc/utils/apaux.h	/^#define OnlineTopic_apaux_h$/;"	d
OnlineTopic_debug_h	inc/utils/debug.h	/^#define OnlineTopic_debug_h$/;"	d
PAmode	inc/paMedLDAave.h	/^	enum PAmode {CLASSIFICATION, REGRESSION};$/;"	g	namespace:paMedLDA_averaging
PLATFORM_ID	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^# define PLATFORM_ID /;"	d	file:
PLATFORM_ID	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define PLATFORM_ID /;"	d	file:
PY_PAMEDLDA_AVE_WRAPPER_H	inc/paMedLDAaveWrapper.h	/^#define PY_PAMEDLDA_AVE_WRAPPER_H$/;"	d
REGRESSION	inc/paMedLDAave.h	/^	enum PAmode {CLASSIFICATION, REGRESSION};$/;"	e	enum:paMedLDA_averaging::PAmode
RM	Makefile	/^RM = \/opt\/local\/bin\/cmake -E remove -f$/;"	m
RM	src/Makefile	/^RM = \/opt\/local\/bin\/cmake -E remove -f$/;"	m
RM	src/utils/Makefile	/^RM = \/opt\/local\/bin\/cmake -E remove -f$/;"	m
SHELL	Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	src/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	src/utils/Makefile	/^SHELL = \/bin\/sh$/;"	m
SIGN	src/paMedLDAave.cpp	/^#define SIGN(/;"	d	file:
SUFFIXES	Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	src/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	src/utils/Makefile	/^SUFFIXES =$/;"	m
Vector	inc/utils/utils.h	/^class Vector : public std::vector<double>{$/;"	c
Z	inc/paMedLDAave.h	/^		int **Z; $/;"	m	class:paMedLDA_averaging::LocalSample
Zbar	inc/paMedLDAave.h	/^		double **Zbar;$/;"	m	class:paMedLDA_averaging::LocalSample
_DEFS_H	inc/utils/defs.h	/^#define _DEFS_H$/;"	d
__HybridMedLDA__objcokus__	inc/utils/objcokus.h	/^#define __HybridMedLDA__objcokus__$/;"	d
__OnlineTopic__Corpus__	inc/Corpus.h	/^#define __OnlineTopic__Corpus__$/;"	d
__OnlineTopic__MVGaussian__	inc/utils/MVGaussian.h	/^#define __OnlineTopic__MVGaussian__$/;"	d
__OnlineTopic__utils__	inc/utils/utils.h	/^#define __OnlineTopic__utils__$/;"	d
___paMedLDA__paMedLDAgibbs__	inc/paMedLDAave.h	/^#define ___paMedLDA__paMedLDAgibbs__$/;"	d
_cholesky_h	inc/utils/cholesky.h	/^#define _cholesky_h$/;"	d
_dadd1	src/utils/ap.cpp	/^typedef void    (*_dadd1)(const double*, const double*, long);$/;"	t	file:
_dadds1	src/utils/ap.cpp	/^typedef void    (*_dadds1)(const double*, const double*, long, double);$/;"	t	file:
_ddot1	src/utils/ap.cpp	/^typedef double  (*_ddot1)(const double*, const double*, long);$/;"	t	file:
_dmove1	src/utils/ap.cpp	/^typedef void    (*_dmove1)(const double*, const double*, long);$/;"	t	file:
_dmoveneg1	src/utils/ap.cpp	/^typedef void    (*_dmoveneg1)(const double*, const double*, long);$/;"	t	file:
_dmoves1	src/utils/ap.cpp	/^typedef void    (*_dmoves1)(const double*, const double*, long, double);$/;"	t	file:
_dmuls1	src/utils/ap.cpp	/^typedef void    (*_dmuls1)(const double*, long, double);$/;"	t	file:
_dsub1	src/utils/ap.cpp	/^typedef void    (*_dsub1)(const double*, const double*, long);$/;"	t	file:
_spdinverse_h	inc/utils/spdinverse.h	/^#define _spdinverse_h$/;"	d
_vadd	inc/utils/apvt.h	/^void _vadd(T *vdst, const T *vsrc, int N)$/;"	f
_vadd	inc/utils/apvt.h	/^void _vadd(T *vdst, const T *vsrc, int N, T2 alpha)$/;"	f
_vdotproduct	inc/utils/apvt.h	/^T _vdotproduct(const T *v1, const T *v2, int N)$/;"	f
_vmove	inc/utils/apvt.h	/^void _vmove(T *vdst, const T *vsrc, int N, T2 alpha)$/;"	f
_vmove	inc/utils/apvt.h	/^void _vmove(T *vdst, const T* vsrc, int N)$/;"	f
_vmoveneg	inc/utils/apvt.h	/^void _vmoveneg(T *vdst, const T *vsrc, int N)$/;"	f
_vmul	inc/utils/apvt.h	/^void _vmul(T *vdst, int N, T2 alpha)$/;"	f
_vsub	inc/utils/apvt.h	/^void _vsub(T *vdst, const T *vsrc, int N)$/;"	f
_vsub	inc/utils/apvt.h	/^void _vsub(T *vdst, const T *vsrc, int N, T2 alpha)$/;"	f
abscomplex	src/utils/ap.cpp	/^const double ap::abscomplex(const ap::complex &z)$/;"	f	class:ap
accuracy	inc/paMedLDAave.h	/^		double time, ob_percent, accuracy;$/;"	m	struct:paMedLDA_averaging::__anon3
active_label	inc/paMedLDAave.h	/^		vector<int>* active_label;	        \/\/ active label queue for sparse PA.$/;"	m	class:paMedLDA_averaging::LocalSample
afree	src/utils/ap.cpp	/^void ap::afree(void *block)$/;"	f	class:ap
alpha	inc/paMedLDAave.h	/^		double alpha, beta, train_time;$/;"	m	class:paMedLDA_averaging::paMedLDAave
amalloc	src/utils/ap.cpp	/^void* ap::amalloc(size_t size, size_t alignment)$/;"	f	class:ap
ap	inc/utils/ap.h	/^namespace ap$/;"	n
ap	inc/utils/apaux.h	/^namespace ap {$/;"	n
ap_error	inc/utils/ap.h	/^    ap_error(){};$/;"	f	class:ap::ap_error
ap_error	inc/utils/ap.h	/^    ap_error(const char *s){ msg = s; };$/;"	f	class:ap::ap_error
ap_error	inc/utils/ap.h	/^class ap_error$/;"	c	namespace:ap
array1d	inc/paMedLDAave.h	/^		std::vector<T*>  array1d;$/;"	m	class:paMedLDA_averaging::Array
array1d	inc/utils/utils.h	/^static T* array1d(int d1) {$/;"	f
array1d_del	inc/utils/utils.h	/^static void array1d_del(T* array) {$/;"	f
array2d	inc/paMedLDAave.h	/^		std::vector<T**> array2d;$/;"	m	class:paMedLDA_averaging::Array
array2d	inc/utils/utils.h	/^static T** array2d(int d1, int d2) {$/;"	f
array2d_del	inc/utils/utils.h	/^static void array2d_del(T** array, int d1) {$/;"	f
array2d_dim	inc/paMedLDAave.h	/^		std::vector<int> array2d_dim;$/;"	m	class:paMedLDA_averaging::Array
beta	inc/paMedLDAave.h	/^		double alpha, beta, train_time;$/;"	m	class:paMedLDA_averaging::paMedLDAave
bias	inc/paMedLDAave.h	/^		double *bias, *prev_bias;	\/\/ bias term for regression.$/;"	m	class:paMedLDA_averaging::GlobalSample
boolean_1d_array	inc/utils/ap.h	/^typedef template_1d_array<bool>         boolean_1d_array;$/;"	t	namespace:ap
boolean_2d_array	inc/utils/ap.h	/^typedef template_2d_array<bool>         boolean_2d_array;$/;"	t	namespace:ap
burnin	inc/paMedLDAave.h	/^		int burnin, burnin_test, samplen_test;$/;"	m	class:paMedLDA_averaging::paMedLDAave
burnin_test	inc/paMedLDAave.h	/^		int burnin, burnin_test, samplen_test;$/;"	m	class:paMedLDA_averaging::paMedLDAave
ceil	inc/utils/utils.h	/^#define ceil(/;"	d
choleskydec	inc/utils/utils.h	/^static bool choleskydec(double **A, double **res, const int &n, bool isupper)$/;"	f
choleskydec	src/utils/MVGaussian.cpp	/^bool MVGaussian::choleskydec(double **A, double **res, const int &n, bool isupper)$/;"	f	class:MVGaussian
choleskydecomposition	src/utils/cholesky.cpp	/^bool choleskydecomposition(ap::real_2d_array& a, int n, bool isupper)$/;"	f
clock_gettime	inc/utils/utils.h	/^static int clock_gettime(struct timespec* t) {$/;"	f
cokus	inc/paMedLDAave.h	/^		objcokus cokus;$/;"	m	class:paMedLDA_averaging::paMedLDAave
cokus	inc/utils/InverseGaussian.h	/^	objcokus cokus;$/;"	m	class:InverseGaussian
cokus	inc/utils/MVGaussian.h	/^	objcokus cokus;$/;"	m	class:MVGaussian
commitTestError	inc/utils/utils.h	/^static void commitTestError( FILE** testErrorFile, double id, double accuracy) {$/;"	f
commit_points	inc/paMedLDAave.h	/^		vector<Commit> commit_points;$/;"	m	class:paMedLDA_averaging::paMedLDAave
commit_points_index	inc/paMedLDAave.h	/^		vector<int> commit_points_index;$/;"	m	class:paMedLDA_averaging::paMedLDAave
complex	inc/utils/ap.h	/^    complex():x(0.0),y(0.0){};$/;"	f	class:ap::complex
complex	inc/utils/ap.h	/^    complex(const complex &z):x(z.x),y(z.y){};$/;"	f	class:ap::complex
complex	inc/utils/ap.h	/^    complex(const double &_x):x(_x),y(0.0){};$/;"	f	class:ap::complex
complex	inc/utils/ap.h	/^    complex(const double &_x, const double &_y):x(_x),y(_y){};$/;"	f	class:ap::complex
complex	inc/utils/ap.h	/^class complex$/;"	c	namespace:ap
complex_1d_array	inc/utils/ap.h	/^typedef template_1d_array<complex>      complex_1d_array;$/;"	t	namespace:ap
complex_2d_array	inc/utils/ap.h	/^typedef template_2d_array<complex>      complex_2d_array;$/;"	t	namespace:ap
conj	src/utils/ap.cpp	/^const ap::complex ap::conj(const ap::complex &z)$/;"	f	class:ap
const_raw_vector	inc/utils/apvt.h	/^    const_raw_vector(const T *Data, int Length, int Step):$/;"	f	class:const_raw_vector
const_raw_vector	inc/utils/apvt.h	/^class const_raw_vector$/;"	c
corpus	inc/paMedLDAave.h	/^		Corpus* corpus;$/;"	m	class:paMedLDA_averaging::paMedLDAave
create_1d	src/paMedLDAave.cpp	/^T* Array<T>::create_1d(int d1) {$/;"	f	class:Array
create_2d	src/paMedLDAave.cpp	/^T** Array<T>::create_2d(int d1, int d2) {$/;"	f	class:Array
create_2d	src/paMedLDAave.cpp	/^T** Array<T>::create_2d(int d1, int* w2) {$/;"	f	class:Array
csqr	src/utils/ap.cpp	/^const ap::complex ap::csqr(const ap::complex &z)$/;"	f	class:ap
dadd1	src/utils/ap.cpp	/^static _dadd1     dadd1     = ABLAS==NULL ? NULL :     (_dadd1)  GetProcAddress(ABLAS, "ASMAdd1");$/;"	v	file:
dadds1	src/utils/ap.cpp	/^static _dadds1    dadds1    = ABLAS==NULL ? NULL :    (_dadds1)  GetProcAddress(ABLAS, "ASMAddS1");$/;"	v	file:
ddot1	src/utils/ap.cpp	/^static _ddot1     ddot1     = ABLAS==NULL ? NULL :     (_ddot1)  GetProcAddress(ABLAS, "ASMDotProduct1");$/;"	v	file:
debug	inc/utils/debug.h	/^static bool debug(char* message, ...) {$/;"	f
debug_indent	inc/utils/debug.h	/^static void debug_indent() {$/;"	f
debug_indentation	inc/utils/debug.h	/^static int debug_indentation = 0;$/;"	v
debug_unindent	inc/utils/debug.h	/^static void debug_unindent() {$/;"	f
del_1d	src/paMedLDAave.cpp	/^void Array<T>::del_1d(T* array) {$/;"	f	class:Array
del_2d	src/paMedLDAave.cpp	/^void Array<T>::del_2d(T** array, int d1) {$/;"	f	class:Array
digamma	inc/utils/utils.h	/^static double digamma(double x) {$/;"	f
discriminant	src/paMedLDAave.cpp	/^double paMedLDAave::discriminant(double* weight, double* cd, double norm) {$/;"	f	class:paMedLDAave
display	inc/utils/utils.h	/^	void display() {$/;"	f	class:Vector
dmove1	src/utils/ap.cpp	/^static _dmove1    dmove1    = ABLAS==NULL ? NULL :    (_dmove1)  GetProcAddress(ABLAS, "ASMMove1");$/;"	v	file:
dmoveneg1	src/utils/ap.cpp	/^static _dmoveneg1 dmoveneg1 = ABLAS==NULL ? NULL : (_dmoveneg1)  GetProcAddress(ABLAS, "ASMMoveNeg1");$/;"	v	file:
dmoves1	src/utils/ap.cpp	/^static _dmoves1   dmoves1   = ABLAS==NULL ? NULL :   (_dmoves1)  GetProcAddress(ABLAS, "ASMMoveS1");$/;"	v	file:
dmuls1	src/utils/ap.cpp	/^static _dmuls1    dmuls1    = ABLAS==NULL ? NULL :     (_dmuls1) GetProcAddress(ABLAS, "ASMMulS1");$/;"	v	file:
doc	inc/Corpus.h	/^	Document* doc; 				\/\/ documents.$/;"	m	struct:__anon2
dot	inc/utils/utils.h	/^	double dot(Vector x) {$/;"	f	class:Vector
dotprod	inc/utils/utils.h	/^static double dotprod( double* veca, double* vecb, int spaceK) {$/;"	f
dsub1	src/utils/ap.cpp	/^static _dsub1     dsub1     = ABLAS==NULL ? NULL :     (_dsub1)  GetProcAddress(ABLAS, "ASMSub1");$/;"	v	file:
eye	inc/utils/apaux.h	/^	static real_2d_array* eye( int n) {$/;"	f	namespace:ap
floor	inc/utils/utils.h	/^#define floor(/;"	d
free2d	inc/utils/utils.h	/^static void free2d( T** m, int n) {$/;"	f
gamma	inc/paMedLDAave.h	/^		double **gamma, **prev_gamma, **stat_gamma;;$/;"	m	class:paMedLDA_averaging::GlobalSample
gammasum	inc/paMedLDAave.h	/^		double *gammasum; $/;"	m	class:paMedLDA_averaging::GlobalSample
getcolumn	inc/utils/ap.h	/^    const_raw_vector<T> getcolumn(int iColumn, int iRowStart, int iRowEnd) const$/;"	f	class:ap::template_2d_array
getcolumn	inc/utils/ap.h	/^    raw_vector<T> getcolumn(int iColumn, int iRowStart, int iRowEnd)$/;"	f	class:ap::template_2d_array
getcontent	inc/utils/ap.h	/^    T* getcontent()$/;"	f	class:ap::template_1d_array
getcontent	inc/utils/ap.h	/^    const T* getcontent() const$/;"	f	class:ap::template_1d_array
gethighbound	inc/utils/ap.h	/^    int gethighbound(int iBoundNum = 0) const$/;"	f	class:ap::template_1d_array
gethighbound	inc/utils/ap.h	/^    int gethighbound(int iBoundNum) const$/;"	f	class:ap::template_2d_array
getlowbound	inc/utils/ap.h	/^    int getlowbound(int iBoundNum = 0) const$/;"	f	class:ap::template_1d_array
getlowbound	inc/utils/ap.h	/^    int getlowbound(int iBoundNum) const$/;"	f	class:ap::template_2d_array
getrow	inc/utils/ap.h	/^    const_raw_vector<T> getrow(int iRow, int iColumnStart, int iColumnEnd) const$/;"	f	class:ap::template_2d_array
getrow	inc/utils/ap.h	/^    raw_vector<T> getrow(int iRow, int iColumnStart, int iColumnEnd)$/;"	f	class:ap::template_2d_array
getvector	inc/utils/ap.h	/^    const_raw_vector<T> getvector(int iStart, int iEnd) const$/;"	f	class:ap::template_1d_array
getvector	inc/utils/ap.h	/^    raw_vector<T> getvector(int iStart, int iEnd)$/;"	f	class:ap::template_1d_array
global	inc/paMedLDAave.h	/^		GlobalSample *global;$/;"	m	class:paMedLDA_averaging::paMedLDAave
hiBit	inc/utils/objcokus.h	/^#define hiBit(/;"	d
iLength	inc/utils/apvt.h	/^    int     iLength, iStep;$/;"	m	class:const_raw_vector
iStep	inc/utils/apvt.h	/^    int     iLength, iStep;$/;"	m	class:const_raw_vector
iceil	src/utils/ap.cpp	/^int ap::iceil(double x)$/;"	f	class:ap
ifloor	src/utils/ap.cpp	/^int ap::ifloor(double x)$/;"	f	class:ap
inferGamma	src/paMedLDAave.cpp	/^void paMedLDAave::inferGamma(vector<int>& index, bool reset) {$/;"	f	class:paMedLDAave
inference	src/paMedLDAave.cpp	/^double paMedLDAave::inference(CorpusData* testData) {$/;"	f	class:paMedLDAave
info_arch	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";$/;"	v
info_arch	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";$/;"	v
info_compiler	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";$/;"	v
info_compiler	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";$/;"	v
info_platform	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";$/;"	v
info_platform	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";$/;"	v
info_version	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^char const info_version[] = {$/;"	v
info_version	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const info_version[] = {$/;"	v
init	src/paMedLDAave.cpp	/^void paMedLDAave::init() {$/;"	f	class:paMedLDAave
integer_1d_array	inc/utils/ap.h	/^typedef template_1d_array<int>          integer_1d_array;$/;"	t	namespace:ap
integer_2d_array	inc/utils/ap.h	/^typedef template_2d_array<int>          integer_2d_array;$/;"	t	namespace:ap
inverse_cholydec	inc/utils/utils.h	/^static void inverse_cholydec(double **A, double **res, double **lowerTriangle, const int &n)$/;"	f
inversecholesky	src/utils/spdinverse.cpp	/^bool inversecholesky(ap::real_2d_array& a, int n, bool isupper)$/;"	f
inversesymmetricpositivedefinite	src/utils/spdinverse.cpp	/^bool inversesymmetricpositivedefinite(ap::real_2d_array& a,$/;"	f
invg_sampler	inc/paMedLDAave.h	/^		InverseGaussian invg_sampler;$/;"	m	class:paMedLDA_averaging::paMedLDAave
label_n	inc/Corpus.h	/^	int label_n;				\/\/ number of labels.$/;"	m	struct:__anon1
left	inc/utils/objcokus.h	/^	int      left;      \/\/ can *next++ this many times before reloading$/;"	m	class:objcokus
lets_batch	inc/paMedLDAave.h	/^		bool lets_batch, lets_multic, lets_commit, lets_bias;$/;"	m	class:paMedLDA_averaging::paMedLDAave
lets_bias	inc/paMedLDAave.h	/^		bool lets_batch, lets_multic, lets_commit, lets_bias;$/;"	m	class:paMedLDA_averaging::paMedLDAave
lets_commit	inc/paMedLDAave.h	/^		bool lets_batch, lets_multic, lets_commit, lets_bias;$/;"	m	class:paMedLDA_averaging::paMedLDAave
lets_multic	inc/paMedLDAave.h	/^		bool lets_batch, lets_multic, lets_commit, lets_bias;$/;"	m	class:paMedLDA_averaging::paMedLDAave
loBit	inc/utils/objcokus.h	/^#define loBit(/;"	d
loBits	inc/utils/objcokus.h	/^#define loBits(/;"	d
loadDataDocument	src/Corpus.cpp	/^bool Corpus::loadDataDocument(FILE* fpin, Document &doc) {$/;"	f	class:Corpus
loadDataDocumentRaw	src/Corpus.cpp	/^bool Corpus::loadDataDocumentRaw(FILE* fpin, Document &doc) {$/;"	f	class:Corpus
loadDataGML	src/Corpus.cpp	/^bool Corpus::loadDataGML(string train_file_path, string test_file_path, bool multi_task, bool raw) {$/;"	f	class:Corpus
local_test	inc/paMedLDAave.h	/^		LocalSample *local_train, *local_test;$/;"	m	class:paMedLDA_averaging::paMedLDAave
local_train	inc/paMedLDAave.h	/^		LocalSample *local_train, *local_test;$/;"	m	class:paMedLDA_averaging::paMedLDAave
m_I	inc/paMedLDAave.h	/^		int m_K, m_T, m_I, m_J, m_Jburnin, m_category, m_labeln;$/;"	m	class:paMedLDA_averaging::paMedLDAave
m_J	inc/paMedLDAave.h	/^		int m_K, m_T, m_I, m_J, m_Jburnin, m_category, m_labeln;$/;"	m	class:paMedLDA_averaging::paMedLDAave
m_Jburnin	inc/paMedLDAave.h	/^		int m_K, m_T, m_I, m_J, m_Jburnin, m_category, m_labeln;$/;"	m	class:paMedLDA_averaging::paMedLDAave
m_K	inc/paMedLDAave.h	/^		int m_K, m_T, m_I, m_J, m_Jburnin, m_category, m_labeln;$/;"	m	class:paMedLDA_averaging::paMedLDAave
m_T	inc/Corpus.h	/^	int m_T;  						\/\/ total number of different words.$/;"	m	class:Corpus
m_T	inc/paMedLDAave.h	/^		int m_K, m_T, m_I, m_J, m_Jburnin, m_category, m_labeln;$/;"	m	class:paMedLDA_averaging::paMedLDAave
m_Vec	inc/utils/ap.h	/^    T           *m_Vec;$/;"	m	class:ap::template_2d_array
m_Vec	inc/utils/ap.h	/^    T         *m_Vec;$/;"	m	class:ap::template_1d_array
m_batchsize	inc/paMedLDAave.h	/^		int m_epoch, m_batchsize, m_dual_steps;$/;"	m	class:paMedLDA_averaging::paMedLDAave
m_c	inc/paMedLDAave.h	/^		double m_c, m_l, m_v, m_v2;$/;"	m	class:paMedLDA_averaging::paMedLDAave
m_category	inc/paMedLDAave.h	/^		int m_K, m_T, m_I, m_J, m_Jburnin, m_category, m_labeln;$/;"	m	class:paMedLDA_averaging::paMedLDAave
m_dGset	inc/utils/InverseGaussian.h	/^	double m_dGset;$/;"	m	class:InverseGaussian
m_dGset	inc/utils/MVGaussian.h	/^	double m_dGset;$/;"	m	class:MVGaussian
m_dMu	inc/utils/InverseGaussian.h	/^	double m_dMu;$/;"	m	class:InverseGaussian
m_dScale	inc/utils/InverseGaussian.h	/^	double m_dScale;$/;"	m	class:InverseGaussian
m_dual_steps	inc/paMedLDAave.h	/^		int m_epoch, m_batchsize, m_dual_steps;$/;"	m	class:paMedLDA_averaging::paMedLDAave
m_epoch	inc/paMedLDAave.h	/^		int m_epoch, m_batchsize, m_dual_steps;$/;"	m	class:paMedLDA_averaging::paMedLDAave
m_iConstOffset	inc/utils/ap.h	/^    long        m_iConstOffset, m_iLinearMember;$/;"	m	class:ap::template_2d_array
m_iHigh	inc/utils/ap.h	/^    long      m_iLow, m_iHigh;$/;"	m	class:ap::template_1d_array
m_iHigh1	inc/utils/ap.h	/^    long        m_iLow1, m_iLow2, m_iHigh1, m_iHigh2;$/;"	m	class:ap::template_2d_array
m_iHigh2	inc/utils/ap.h	/^    long        m_iLow1, m_iLow2, m_iHigh1, m_iHigh2;$/;"	m	class:ap::template_2d_array
m_iLinearMember	inc/utils/ap.h	/^    long        m_iConstOffset, m_iLinearMember;$/;"	m	class:ap::template_2d_array
m_iLow	inc/utils/ap.h	/^    long      m_iLow, m_iHigh;$/;"	m	class:ap::template_1d_array
m_iLow1	inc/utils/ap.h	/^    long        m_iLow1, m_iLow2, m_iHigh1, m_iHigh2;$/;"	m	class:ap::template_2d_array
m_iLow2	inc/utils/ap.h	/^    long        m_iLow1, m_iLow2, m_iHigh1, m_iHigh2;$/;"	m	class:ap::template_2d_array
m_iSet	inc/utils/InverseGaussian.h	/^	int m_iSet;$/;"	m	class:InverseGaussian
m_iSet	inc/utils/MVGaussian.h	/^	int m_iSet;$/;"	m	class:MVGaussian
m_iVecSize	inc/utils/ap.h	/^    long        m_iVecSize;$/;"	m	class:ap::template_2d_array
m_iVecSize	inc/utils/ap.h	/^    long      m_iVecSize;$/;"	m	class:ap::template_1d_array
m_l	inc/paMedLDAave.h	/^		double m_c, m_l, m_v, m_v2;$/;"	m	class:paMedLDA_averaging::paMedLDAave
m_labeln	inc/paMedLDAave.h	/^		int m_K, m_T, m_I, m_J, m_Jburnin, m_category, m_labeln;$/;"	m	class:paMedLDA_averaging::paMedLDAave
m_v	inc/paMedLDAave.h	/^		double m_c, m_l, m_v, m_v2;$/;"	m	class:paMedLDA_averaging::paMedLDAave
m_v2	inc/paMedLDAave.h	/^		double m_c, m_l, m_v, m_v2;$/;"	m	class:paMedLDA_averaging::paMedLDAave
machineepsilon	src/utils/ap.cpp	/^const double ap::machineepsilon = 5E-16;$/;"	m	class:ap	file:
main	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^int main(int argc, char* argv[])$/;"	f
main	CMakeFiles/2.8.12.2/CompilerIdC/CMakeCCompilerId.c	/^void main() {}$/;"	f
main	CMakeFiles/2.8.12.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^int main(int argc, char* argv[])$/;"	f
main	src/main.cpp	/^int main(int argc, const char * argv[])$/;"	f
make_assertion	inc/utils/ap.h	/^    static void make_assertion(bool bClause)$/;"	f	class:ap::ap_error
make_assertion	inc/utils/ap.h	/^    static void make_assertion(bool bClause, const char *msg)$/;"	f	class:ap::ap_error
maxint	src/utils/ap.cpp	/^int ap::maxint(int m1, int m2)$/;"	f	class:ap
maxreal	src/utils/ap.cpp	/^double ap::maxreal(double m1, double m2)$/;"	f	class:ap
maxrealnumber	src/utils/ap.cpp	/^const double ap::maxrealnumber  = 1E300;$/;"	m	class:ap	file:
mem_double	inc/paMedLDAave.h	/^		Array<double> mem_double;$/;"	m	class:paMedLDA_averaging::paMedLDAave
mem_int	inc/paMedLDAave.h	/^		Array<int> mem_int;$/;"	m	class:paMedLDA_averaging::paMedLDAave
minint	src/utils/ap.cpp	/^int ap::minint(int m1, int m2)$/;"	f	class:ap
minreal	src/utils/ap.cpp	/^double ap::minreal(double m1, double m2)$/;"	f	class:ap
minrealnumber	src/utils/ap.cpp	/^const double ap::minrealnumber  = 1E-300;$/;"	m	class:ap	file:
mixBits	inc/utils/objcokus.h	/^#define mixBits(/;"	d
mode	inc/paMedLDAave.h	/^		PAmode mode; $/;"	m	class:paMedLDA_averaging::paMedLDAave
msg	inc/utils/ap.h	/^    std::string msg;$/;"	m	class:ap::ap_error
multi_label	inc/Corpus.h	/^	bool multi_label;				\/\/ is this a multi-label corpus.$/;"	m	class:Corpus
mvGaussian_sampler	inc/paMedLDAave.h	/^		MVGaussian mvGaussian_sampler;$/;"	m	class:paMedLDA_averaging::paMedLDAave
my	inc/paMedLDAave.h	/^		double **my;						\/\/ predicted label with confidence.$/;"	m	class:paMedLDA_averaging::LocalSample
my	inc/paMedLDAave.h	/^		double* my;$/;"	m	struct:paMedLDA_averaging::__anon3
myrand	inc/utils/defs.h	/^#define myrand(/;"	d
nd	inc/Corpus.h	/^	int nd;						\/\/ number of words in the document.$/;"	m	struct:__anon1
new_1d	src/paMedLDAave.cpp	/^T* Array<T>::new_1d(int d1) {$/;"	f	class:Array
new_2d	src/paMedLDAave.cpp	/^T** Array<T>::new_2d(int d1, int d2) {$/;"	f	class:Array
new_2d	src/paMedLDAave.cpp	/^T** Array<T>::new_2d(int d1, int* w2) {$/;"	f	class:Array
newsgroup_n	inc/Corpus.h	/^	int newsgroup_n; 				\/\/ total number of newsgroups.$/;"	m	class:Corpus
next	inc/utils/objcokus.h	/^	uint32   *next;          \/\/ next random value is computed from here$/;"	m	class:objcokus
nextGaussian	src/utils/InverseGaussian.cpp	/^double InverseGaussian::nextGaussian()$/;"	f	class:InverseGaussian
nextGaussian	src/utils/MVGaussian.cpp	/^double MVGaussian::nextGaussian()$/;"	f	class:MVGaussian
nextMVGaussian	src/utils/MVGaussian.cpp	/^void MVGaussian::nextMVGaussian(double *mean, double **precision, double *res, const int &n)$/;"	f	class:MVGaussian
nextMVGaussianWithCholesky	src/utils/MVGaussian.cpp	/^void MVGaussian::nextMVGaussianWithCholesky(double *mean, double **precisionLowerTriangular, double *res, const int &n)$/;"	f	class:MVGaussian
nextMVGaussianWithCholeskyAp	src/utils/MVGaussian.cpp	/^void MVGaussian::nextMVGaussianWithCholeskyAp(ap::real_2d_array& mean, ap::real_2d_array& precisionLowerTriangular, ap::real_2d_array& res) {$/;"	f	class:MVGaussian
norm	inc/utils/utils.h	/^	double norm(int ell = 2) {$/;"	f	class:Vector
normGamma	src/paMedLDAave.cpp	/^void paMedLDAave::normGamma(int N, bool remove) {$/;"	f	class:paMedLDAave
ob_percent	inc/paMedLDAave.h	/^		double time, ob_percent, accuracy;$/;"	m	struct:paMedLDA_averaging::__anon3
objcokus	inc/utils/objcokus.h	/^	objcokus()$/;"	f	class:objcokus
objcokus	inc/utils/objcokus.h	/^class objcokus {$/;"	c
operator !=	src/utils/ap.cpp	/^const bool ap::operator!=(const ap::complex& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator ()	inc/utils/ap.h	/^    T& operator()(int i)$/;"	f	class:ap::template_1d_array
operator ()	inc/utils/ap.h	/^    T& operator()(int i1, int i2)$/;"	f	class:ap::template_2d_array
operator ()	inc/utils/ap.h	/^    const T& operator()(int i) const$/;"	f	class:ap::template_1d_array
operator ()	inc/utils/ap.h	/^    const T& operator()(int i1, int i2) const$/;"	f	class:ap::template_2d_array
operator *	inc/utils/ap.h	/^	template_2d_array<T,Aligned>& operator*( template_2d_array<T,Aligned>& b) {$/;"	f	class:ap::template_2d_array
operator *	inc/utils/utils.h	/^	Vector operator*(double x) {$/;"	f	class:Vector
operator *	src/utils/ap.cpp	/^const ap::complex ap::operator*(const ap::complex& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator *	src/utils/ap.cpp	/^const ap::complex ap::operator*(const ap::complex& lhs, const double& rhs)$/;"	f	class:ap
operator *	src/utils/ap.cpp	/^const ap::complex ap::operator*(const double& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator *=	inc/utils/ap.h	/^    complex& operator*=(const complex& z){ double t = x*z.x-y*z.y; y = x*z.y+y*z.x; x = t; return *this; };$/;"	f	class:ap::complex
operator *=	inc/utils/ap.h	/^    complex& operator*=(const double& v){ x *= v; y *= v;  return *this; };$/;"	f	class:ap::complex
operator +	inc/utils/ap.h	/^	template_2d_array<T,Aligned>& operator+( template_2d_array<T,Aligned>& b) {$/;"	f	class:ap::template_2d_array
operator +	inc/utils/utils.h	/^	Vector operator+(Vector x) {$/;"	f	class:Vector
operator +	src/utils/ap.cpp	/^const ap::complex ap::operator+(const ap::complex& lhs)$/;"	f	class:ap
operator +	src/utils/ap.cpp	/^const ap::complex ap::operator+(const ap::complex& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator +	src/utils/ap.cpp	/^const ap::complex ap::operator+(const ap::complex& lhs, const double& rhs)$/;"	f	class:ap
operator +	src/utils/ap.cpp	/^const ap::complex ap::operator+(const double& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator +=	inc/utils/ap.h	/^    complex& operator+=(const complex& z){ x += z.x; y += z.y; return *this; };$/;"	f	class:ap::complex
operator +=	inc/utils/ap.h	/^    complex& operator+=(const double& v){ x += v;          return *this; };$/;"	f	class:ap::complex
operator -	inc/utils/utils.h	/^	Vector operator-(Vector x) {$/;"	f	class:Vector
operator -	src/utils/ap.cpp	/^const ap::complex ap::operator-(const ap::complex& lhs)$/;"	f	class:ap
operator -	src/utils/ap.cpp	/^const ap::complex ap::operator-(const ap::complex& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator -	src/utils/ap.cpp	/^const ap::complex ap::operator-(const ap::complex& lhs, const double& rhs)$/;"	f	class:ap
operator -	src/utils/ap.cpp	/^const ap::complex ap::operator-(const double& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator -=	inc/utils/ap.h	/^    complex& operator-=(const complex& z){ x -= z.x; y -= z.y; return *this; };$/;"	f	class:ap::complex
operator -=	inc/utils/ap.h	/^    complex& operator-=(const double& v){ x -= v;          return *this; };$/;"	f	class:ap::complex
operator /	inc/utils/utils.h	/^	Vector operator\/(double x) {$/;"	f	class:Vector
operator /	src/utils/ap.cpp	/^const ap::complex ap::operator\/(const ap::complex& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator /	src/utils/ap.cpp	/^const ap::complex ap::operator\/(const ap::complex& lhs, const double& rhs)$/;"	f	class:ap
operator /	src/utils/ap.cpp	/^const ap::complex ap::operator\/(const double& lhs, const ap::complex& rhs)$/;"	f	class:ap
operator /=	inc/utils/ap.h	/^    complex& operator\/=(const complex& z)$/;"	f	class:ap::complex
operator /=	inc/utils/ap.h	/^    complex& operator\/=(const double& v){ x \/= v; y \/= v;  return *this; };$/;"	f	class:ap::complex
operator =	inc/utils/ap.h	/^    complex& operator= (const complex& z){ x  = z.x; y  = z.y; return *this; };$/;"	f	class:ap::complex
operator =	inc/utils/ap.h	/^    complex& operator= (const double& v){ x  = v; y = 0.0; return *this; };$/;"	f	class:ap::complex
operator =	inc/utils/ap.h	/^    const template_1d_array& operator=(const template_1d_array &rhs)$/;"	f	class:ap::template_1d_array
operator =	inc/utils/ap.h	/^    const template_2d_array& operator=(const template_2d_array &rhs)$/;"	f	class:ap::template_2d_array
operator ==	src/utils/ap.cpp	/^const bool ap::operator==(const ap::complex& lhs, const ap::complex& rhs)$/;"	f	class:ap
pData	inc/utils/apvt.h	/^    T       *pData;$/;"	m	class:const_raw_vector
paMedLDA_averaging	inc/paMedLDAave.h	/^namespace paMedLDA_averaging {$/;"	n
paMedLDAave	inc/paMedLDAave.h	/^	class paMedLDAave {$/;"	c	namespace:paMedLDA_averaging
paMedLDAave	src/paMedLDAave.cpp	/^paMedLDAave::paMedLDAave(Corpus* corpus, int m_category) {$/;"	f	class:paMedLDAave
paMedLDAaveWrapper	inc/paMedLDAaveWrapper.h	/^struct paMedLDAaveWrapper {$/;"	s
paMedLDAaveWrapper	src/paMedLDAaveWrapper.cpp	/^paMedLDAaveWrapper::paMedLDAaveWrapper(boost::python::dict config) $/;"	f	class:paMedLDAaveWrapper
pamedlda	experiment.py	/^pamedlda = /;"	v
pamedlda	inc/paMedLDAaveWrapper.h	/^	vector<shared_ptr<paMedLDAave> > pamedlda;$/;"	m	struct:paMedLDAaveWrapper
path	src/main.cpp	/^string path = "..\/..\/..\/data\/";$/;"	v
path_kaggle	src/main.cpp	/^string path_kaggle = "..\/..\/..\/..\/kaggle\/";$/;"	v
pi	src/utils/ap.cpp	/^double ap::pi()$/;"	f	class:ap
prev_bias	inc/paMedLDAave.h	/^		double *bias, *prev_bias;	\/\/ bias term for regression.$/;"	m	class:paMedLDA_averaging::GlobalSample
prev_gamma	inc/paMedLDAave.h	/^		double **gamma, **prev_gamma, **stat_gamma;;$/;"	m	class:paMedLDA_averaging::GlobalSample
prev_gamma_list_end	inc/paMedLDAave.h	/^		int *prev_gamma_list_k, *prev_gamma_list_t, prev_gamma_list_end;$/;"	m	class:paMedLDA_averaging::GlobalSample
prev_gamma_list_k	inc/paMedLDAave.h	/^		int *prev_gamma_list_k, *prev_gamma_list_t, prev_gamma_list_end;$/;"	m	class:paMedLDA_averaging::GlobalSample
prev_gamma_list_t	inc/paMedLDAave.h	/^		int *prev_gamma_list_k, *prev_gamma_list_t, prev_gamma_list_end;$/;"	m	class:paMedLDA_averaging::GlobalSample
prev_weight_mean	inc/paMedLDAave.h	/^		double **weight_mean, **prev_weight_mean;$/;"	m	class:paMedLDA_averaging::GlobalSample
py	inc/paMedLDAave.h	/^		double **py;						\/\/ predicted label.$/;"	m	class:paMedLDA_averaging::LocalSample
random01	inc/utils/objcokus.h	/^	double random01() {$/;"	f	class:objcokus
randomMT	inc/utils/objcokus.h	/^	uint32 randomMT(void)$/;"	f	class:objcokus
randominteger	src/utils/ap.cpp	/^int ap::randominteger(int maxv)$/;"	f	class:ap
randomreal	src/utils/ap.cpp	/^double ap::randomreal()$/;"	f	class:ap
raw_vector	inc/utils/apvt.h	/^    raw_vector(T *Data, int Length, int Step):const_raw_vector<T>(Data, Length, Step){};$/;"	f	class:raw_vector
raw_vector	inc/utils/apvt.h	/^class raw_vector : public const_raw_vector<T>$/;"	c
real_1d_array	inc/utils/ap.h	/^typedef template_1d_array<double,true>  real_1d_array;$/;"	t	namespace:ap
real_2d_array	inc/utils/ap.h	/^typedef template_2d_array<double,true>  real_2d_array;$/;"	t	namespace:ap
reloadMT	inc/utils/objcokus.h	/^	uint32 reloadMT(void)$/;"	f	class:objcokus
reset	inc/utils/InverseGaussian.h	/^	void reset(double dMu, double dScale) {$/;"	f	class:InverseGaussian
round	src/utils/ap.cpp	/^int ap::round(double x)$/;"	f	class:ap
sample	src/utils/InverseGaussian.cpp	/^double InverseGaussian::sample()$/;"	f	class:InverseGaussian
samplen_test	inc/paMedLDAave.h	/^		int burnin, burnin_test, samplen_test;$/;"	m	class:paMedLDA_averaging::paMedLDAave
sampler_inference	src/main.cpp	/^void* sampler_inference(void* _pamedlda) {$/;"	f
sampler_train	src/main.cpp	/^void* sampler_train(void* _pamedlda) {$/;"	f
seedMT	inc/utils/objcokus.h	/^	void seedMT(uint32 seed)$/;"	f	class:objcokus
setbounds	inc/utils/ap.h	/^    void setbounds( int iLow, int iHigh )$/;"	f	class:ap::template_1d_array
setbounds	inc/utils/ap.h	/^    void setbounds( int iLow1, int iHigh1, int iLow2, int iHigh2 )$/;"	f	class:ap::template_2d_array
setcontent	inc/utils/ap.h	/^    void setcontent( int iLow, int iHigh, const T *pContent )$/;"	f	class:ap::template_1d_array
setcontent	inc/utils/ap.h	/^    void setcontent( int iLow1, int iHigh1, int iLow2, int iHigh2, const T *pContent )$/;"	f	class:ap::template_2d_array
setshape	inc/utils/ap.h	/^	void setshape( int iHigh1, int iHigh2) {$/;"	f	class:ap::template_2d_array
shape	inc/utils/ap.h	/^	int shape( int dim) const {$/;"	f	class:ap::template_2d_array
shuffleArray	inc/utils/utils.h	/^static void shuffleArray(type *idx, int D) {$/;"	f
sign	src/utils/ap.cpp	/^int ap::sign(double x)$/;"	f	class:ap
sp_gamma	inc/utils/utils.h	/^static double sp_gamma(double z)$/;"	f
spdmatrixcholesky	src/utils/cholesky.cpp	/^bool spdmatrixcholesky(ap::real_2d_array& a, int n, bool isupper)$/;"	f
spdmatrixcholeskyinverse	src/utils/spdinverse.cpp	/^bool spdmatrixcholeskyinverse(ap::real_2d_array& a, int n, bool isupper)$/;"	f
spdmatrixinverse	src/utils/spdinverse.cpp	/^bool spdmatrixinverse(ap::real_2d_array& a, int n, bool isupper)$/;"	f
splitWords	inc/utils/utils.h	/^static list<int>* splitWords( string text, map<string,int>* dic) {$/;"	f
splitWords	inc/utils/utils.h	/^static list<string>* splitWords( string text) {$/;"	f
sqr	src/utils/ap.cpp	/^double ap::sqr(double x)$/;"	f	class:ap
st_gamma	inc/utils/utils.h	/^static double st_gamma(double x)$/;"	f
stat_gamma	inc/paMedLDAave.h	/^		double **gamma, **prev_gamma, **stat_gamma;;$/;"	m	class:paMedLDA_averaging::GlobalSample
stat_gamma_list_end	inc/paMedLDAave.h	/^		int *stat_gamma_list_k, *stat_gamma_list_t, stat_gamma_list_end; $/;"	m	class:paMedLDA_averaging::GlobalSample
stat_gamma_list_k	inc/paMedLDAave.h	/^		int *stat_gamma_list_k, *stat_gamma_list_t, stat_gamma_list_end; $/;"	m	class:paMedLDA_averaging::GlobalSample
stat_gamma_list_t	inc/paMedLDAave.h	/^		int *stat_gamma_list_k, *stat_gamma_list_t, stat_gamma_list_end; $/;"	m	class:paMedLDA_averaging::GlobalSample
state	inc/utils/objcokus.h	/^	uint32   state[MT_NT+1];     \/\/ state vector + 1 extra to not violate ANSI C$/;"	m	class:objcokus
tag_imap	inc/Corpus.h	/^	map<int, string> word_imap, tag_imap;$/;"	m	class:Corpus
tag_map	inc/Corpus.h	/^	map<string, int> word_map, tag_map;$/;"	m	class:Corpus
tau	inc/paMedLDAave.h	/^		double **tau;						\/\/ solution of the dual problem.$/;"	m	class:paMedLDA_averaging::LocalSample
template_1d_array	inc/utils/ap.h	/^    template_1d_array()$/;"	f	class:ap::template_1d_array
template_1d_array	inc/utils/ap.h	/^    template_1d_array(const template_1d_array &rhs)$/;"	f	class:ap::template_1d_array
template_1d_array	inc/utils/ap.h	/^class template_1d_array$/;"	c	namespace:ap
template_2d_array	inc/utils/ap.h	/^    template_2d_array()$/;"	f	class:ap::template_2d_array
template_2d_array	inc/utils/ap.h	/^    template_2d_array(const template_2d_array &rhs)$/;"	f	class:ap::template_2d_array
template_2d_array	inc/utils/ap.h	/^class template_2d_array$/;"	c	namespace:ap
test_data	inc/Corpus.h	/^	CorpusData train_data, test_data;$/;"	m	class:Corpus
test_data	inc/paMedLDAave.h	/^		CorpusData *train_data, *test_data;$/;"	m	class:paMedLDA_averaging::paMedLDAave
test_score	inc/paMedLDAave.h	/^		double test_score;$/;"	m	class:paMedLDA_averaging::paMedLDAave
time	inc/paMedLDAave.h	/^		double time, ob_percent, accuracy;$/;"	m	struct:paMedLDA_averaging::__anon3
toLowerCase	inc/utils/utils.h	/^static string toLowerCase( string str) {$/;"	f
train	src/paMedLDAave.cpp	/^double paMedLDAave::train() {$/;"	f	class:paMedLDAave
train	src/paMedLDAaveWrapper.cpp	/^void paMedLDAaveWrapper::train(boost::python::object num_iter) {$/;"	f	class:paMedLDAaveWrapper
train_data	inc/Corpus.h	/^	CorpusData train_data, test_data;$/;"	m	class:Corpus
train_data	inc/paMedLDAave.h	/^		CorpusData *train_data, *test_data;$/;"	m	class:paMedLDA_averaging::paMedLDAave
train_time	inc/paMedLDAave.h	/^		double alpha, beta, train_time;$/;"	m	class:paMedLDA_averaging::paMedLDAave
trans	inc/utils/ap.h	/^	template_2d_array<T,Aligned>& trans() {$/;"	f	class:ap::template_2d_array
trunc	src/utils/ap.cpp	/^int ap::trunc(double x)$/;"	f	class:ap
uint32	inc/utils/objcokus.h	/^typedef unsigned long uint32;$/;"	t
updateWeight	src/paMedLDAave.cpp	/^void paMedLDAave::updateWeight(vector<int>& index, int N, bool remove) {$/;"	f	class:paMedLDAave
updateZ	src/paMedLDAave.cpp	/^void paMedLDAave::updateZ(vector<int>& index) {$/;"	f	class:paMedLDAave
updateZTest	src/paMedLDAave.cpp	/^void paMedLDAave::updateZTest(int d, double& lhood, objcokus& cokus) {$/;"	f	class:paMedLDAave
vadd	inc/utils/apvt.h	/^void vadd(raw_vector<T> vdst, const_raw_vector<T> vsrc)$/;"	f
vadd	inc/utils/apvt.h	/^void vadd(raw_vector<T> vdst, const_raw_vector<T> vsrc, T2 alpha)$/;"	f
vadd	src/utils/ap.cpp	/^void ap::vadd(ap::complex *vdst, const ap::complex *vsrc, int N)$/;"	f	class:ap
vadd	src/utils/ap.cpp	/^void ap::vadd(ap::complex *vdst, const ap::complex *vsrc, int N, ap::complex alpha)$/;"	f	class:ap
vadd	src/utils/ap.cpp	/^void ap::vadd(ap::complex *vdst, const ap::complex *vsrc, int N, double alpha)$/;"	f	class:ap
vadd	src/utils/ap.cpp	/^void ap::vadd(double *vdst, const double *vsrc, int N)$/;"	f	class:ap
vadd	src/utils/ap.cpp	/^void ap::vadd(double *vdst, const double *vsrc, int N, double alpha)$/;"	f	class:ap
vdotproduct	inc/utils/apvt.h	/^T vdotproduct(const_raw_vector<T> v1, const_raw_vector<T> v2)$/;"	f
vdotproduct	src/utils/ap.cpp	/^ap::complex ap::vdotproduct(const ap::complex *v1, const ap::complex *v2, int N)$/;"	f	class:ap
vdotproduct	src/utils/ap.cpp	/^double ap::vdotproduct(const double *v1, const double *v2, int N)$/;"	f	class:ap
vecabs	inc/utils/utils.h	/^static void vecabs( double* veca, int spaceK) {$/;"	f
vecadd	inc/utils/utils.h	/^static void vecadd( double* veca, double* vecb, int spaceK) {$/;"	f
vecdivs	inc/utils/utils.h	/^static void vecdivs( double* veca, double x, int spaceK) {$/;"	f
vecmul	inc/utils/utils.h	/^static void vecmul( double* veca, double* vecb, int spaceK) {$/;"	f
vecmuls	inc/utils/utils.h	/^static void vecmuls( double* veca, double x, int spaceK) {$/;"	f
vecsqr	inc/utils/utils.h	/^static void vecsqr( double* veca, int spaceK) {$/;"	f
vecsub	inc/utils/utils.h	/^static void vecsub( double* veca, double* vecb, int spaceK) {$/;"	f
vecsubs	inc/utils/utils.h	/^static void vecsubs( double* veca, double scalar, int spaceK) {$/;"	f
vecsum	inc/utils/utils.h	/^static double vecsum( double* veca, int spaceK) {$/;"	f
visualize	inc/utils/ap.h	/^	void visualize() {$/;"	f	class:ap::template_2d_array
visualize	inc/utils/apaux.h	/^	static void visualize( real_2d_array& array) {$/;"	f	namespace:ap
vlen	src/utils/ap.cpp	/^int ap::vlen(int n1, int n2)$/;"	f	class:ap
vmove	inc/utils/apvt.h	/^void vmove(raw_vector<T> vdst, const_raw_vector<T> vsrc)$/;"	f
vmove	inc/utils/apvt.h	/^void vmove(raw_vector<T> vdst, const_raw_vector<T> vsrc, T2 alpha)$/;"	f
vmove	src/utils/ap.cpp	/^void ap::vmove(ap::complex *vdst, const ap::complex *vsrc, int N, ap::complex alpha)$/;"	f	class:ap
vmove	src/utils/ap.cpp	/^void ap::vmove(ap::complex *vdst, const ap::complex *vsrc, int N, double alpha)$/;"	f	class:ap
vmove	src/utils/ap.cpp	/^void ap::vmove(ap::complex *vdst, const ap::complex* vsrc, int N)$/;"	f	class:ap
vmove	src/utils/ap.cpp	/^void ap::vmove(double *vdst, const double *vsrc, int N, double alpha)$/;"	f	class:ap
vmove	src/utils/ap.cpp	/^void ap::vmove(double *vdst, const double* vsrc, int N)$/;"	f	class:ap
vmoveneg	inc/utils/apvt.h	/^void vmoveneg(raw_vector<T> vdst, const_raw_vector<T> vsrc)$/;"	f
vmoveneg	src/utils/ap.cpp	/^void ap::vmoveneg(ap::complex *vdst, const ap::complex *vsrc, int N)$/;"	f	class:ap
vmoveneg	src/utils/ap.cpp	/^void ap::vmoveneg(double *vdst, const double *vsrc, int N)$/;"	f	class:ap
vmul	inc/utils/apvt.h	/^void vmul(raw_vector<T> vdst, T2 alpha)$/;"	f
vmul	src/utils/ap.cpp	/^void ap::vmul(ap::complex *vdst, int N, ap::complex alpha)$/;"	f	class:ap
vmul	src/utils/ap.cpp	/^void ap::vmul(ap::complex *vdst, int N, double alpha)$/;"	f	class:ap
vmul	src/utils/ap.cpp	/^void ap::vmul(double *vdst, int N, double alpha)$/;"	f	class:ap
vsub	inc/utils/apvt.h	/^void vsub(raw_vector<T> vdst, const_raw_vector<T> vsrc)$/;"	f
vsub	inc/utils/apvt.h	/^void vsub(raw_vector<T> vdst, const_raw_vector<T> vsrc, T2 alpha)$/;"	f
vsub	src/utils/ap.cpp	/^void ap::vsub(ap::complex *vdst, const ap::complex *vsrc, int N)$/;"	f	class:ap
vsub	src/utils/ap.cpp	/^void ap::vsub(ap::complex *vdst, const ap::complex *vsrc, int N, ap::complex alpha)$/;"	f	class:ap
vsub	src/utils/ap.cpp	/^void ap::vsub(ap::complex *vdst, const ap::complex *vsrc, int N, double alpha)$/;"	f	class:ap
vsub	src/utils/ap.cpp	/^void ap::vsub(double *vdst, const double *vsrc, int N)$/;"	f	class:ap
vsub	src/utils/ap.cpp	/^void ap::vsub(double *vdst, const double *vsrc, int N, double alpha)$/;"	f	class:ap
weight_mean	inc/paMedLDAave.h	/^		double **weight_mean, **prev_weight_mean;$/;"	m	class:paMedLDA_averaging::GlobalSample
word_imap	inc/Corpus.h	/^	map<int, string> word_imap, tag_imap;$/;"	m	class:Corpus
word_map	inc/Corpus.h	/^	map<string, int> word_map, tag_map;$/;"	m	class:Corpus
words	inc/Corpus.h	/^	int *words;					\/\/ words in the document.$/;"	m	struct:__anon1
wrongColumn	inc/utils/ap.h	/^    bool wrongColumn(int j) const { return j<m_iLow2 || j>m_iHigh2; };$/;"	f	class:ap::template_2d_array
wrongIdx	inc/utils/ap.h	/^    bool wrongIdx(int i) const { return i<m_iLow || i>m_iHigh; };$/;"	f	class:ap::template_1d_array
wrongRow	inc/utils/ap.h	/^    bool wrongRow(int i) const { return i<m_iLow1 || i>m_iHigh1; };$/;"	f	class:ap::template_2d_array
x	inc/utils/ap.h	/^    double x, y;$/;"	m	class:ap::complex
y	inc/Corpus.h	/^	double *y;					\/\/ label and predicted label (allow multi-task).$/;"	m	struct:__anon1
y	inc/utils/ap.h	/^    double x, y;$/;"	m	class:ap::complex
zeros	inc/utils/apaux.h	/^	static real_2d_array* zeros( int m, int n) {$/;"	f	namespace:ap
~Array	src/paMedLDAave.cpp	/^Array<T>::~Array() {$/;"	f	class:Array
~InverseGaussian	src/utils/InverseGaussian.cpp	/^InverseGaussian::~InverseGaussian(void)$/;"	f	class:InverseGaussian
~LocalSample	src/paMedLDAave.cpp	/^LocalSample::~LocalSample() {$/;"	f	class:LocalSample
~MVGaussian	src/utils/MVGaussian.cpp	/^MVGaussian::~MVGaussian(void)$/;"	f	class:MVGaussian
~paMedLDAave	src/paMedLDAave.cpp	/^paMedLDAave::~paMedLDAave() {$/;"	f	class:paMedLDAave
~paMedLDAaveWrapper	src/paMedLDAaveWrapper.cpp	/^paMedLDAaveWrapper::~paMedLDAaveWrapper() $/;"	f	class:paMedLDAaveWrapper
~template_1d_array	inc/utils/ap.h	/^    ~template_1d_array()$/;"	f	class:ap::template_1d_array
~template_2d_array	inc/utils/ap.h	/^    ~template_2d_array()$/;"	f	class:ap::template_2d_array
